// Code generated by sudo-gen copy. DO NOT EDIT.

package basic

import (
	"testing"
)

func TestConfigCopyNil(t *testing.T) {
	var c *Config
	got := c.Copy()
	if got != nil {
		t.Errorf("expected nil, got %v", got)
	}
}

func TestConfigCopyEmpty(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got == nil {
		t.Fatal("expected non-nil copy")
	}
	if got == c {
		t.Error("copy should be a different pointer")
	}
}

func TestConfigCopyIndependence(t *testing.T) {
	c := &Config{}
	got := c.Copy()

	// Modify original - copy should not change
	// This is a basic test; manual verification recommended for complex types
	if got == c {
		t.Error("copy should be independent from original")
	}
}

func TestConfigCopy_HostsSlice(t *testing.T) {
	c := &Config{
		Hosts: make([]string, 2),
	}
	got := c.Copy()
	if got.Hosts == nil {
		t.Fatal("expected slice to be copied")
	}
	if len(got.Hosts) != len(c.Hosts) {
		t.Errorf("expected len %d, got %d", len(c.Hosts), len(got.Hosts))
	}
	// Verify independence by checking slice headers differ
	if len(c.Hosts) > 0 && &got.Hosts[0] == &c.Hosts[0] {
		t.Error("slice should be a deep copy, not share backing array")
	}
}

func TestConfigCopy_HostsSliceNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Hosts != nil {
		t.Error("nil slice should remain nil after copy")
	}
}

func TestConfigCopy_HostsSliceIndependence(t *testing.T) {
	c := &Config{
		Hosts: make([]string, 1),
	}
	got := c.Copy()
	if len(c.Hosts) == 0 {
		t.Skip("slice has no elements to test")
	}
	// Original slice length should not affect copy length
	originalLen := len(c.Hosts)
	c.Hosts = append(c.Hosts, c.Hosts[0])
	if len(got.Hosts) != originalLen {
		t.Error("modifications to original slice should not affect copy")
	}
}

func TestConfigCopy_TagsSlice(t *testing.T) {
	c := &Config{
		Tags: make([]Tag, 2),
	}
	got := c.Copy()
	if got.Tags == nil {
		t.Fatal("expected slice to be copied")
	}
	if len(got.Tags) != len(c.Tags) {
		t.Errorf("expected len %d, got %d", len(c.Tags), len(got.Tags))
	}
	// Verify independence by checking slice headers differ
	if len(c.Tags) > 0 && &got.Tags[0] == &c.Tags[0] {
		t.Error("slice should be a deep copy, not share backing array")
	}
}

func TestConfigCopy_TagsSliceNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Tags != nil {
		t.Error("nil slice should remain nil after copy")
	}
}

func TestConfigCopy_TagsSliceIndependence(t *testing.T) {
	c := &Config{
		Tags: make([]Tag, 1),
	}
	got := c.Copy()
	if len(c.Tags) == 0 {
		t.Skip("slice has no elements to test")
	}
	// Original slice length should not affect copy length
	originalLen := len(c.Tags)
	c.Tags = append(c.Tags, c.Tags[0])
	if len(got.Tags) != originalLen {
		t.Error("modifications to original slice should not affect copy")
	}
}

func TestConfigCopy_LabelsMap(t *testing.T) {
	c := &Config{
		Labels: make(map[string]string),
	}
	got := c.Copy()
	if got.Labels == nil {
		t.Fatal("expected map to be copied")
	}
}

func TestConfigCopy_LabelsMapNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Labels != nil {
		t.Error("nil map should remain nil after copy")
	}
}

func TestConfigCopy_LabelsMapIndependence(t *testing.T) {
	c := &Config{
		Labels: make(map[string]string),
	}
	got := c.Copy()
	// Verify map independence - mutations to original should not affect copy
	if got.Labels == nil {
		t.Fatal("expected map to be copied")
	}
	// Maps are copied by value, so they should be different instances
}

func TestConfigCopy_MetadataMap(t *testing.T) {
	c := &Config{
		Metadata: make(map[string]any),
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
}

func TestConfigCopy_MetadataMapNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Metadata != nil {
		t.Error("nil map should remain nil after copy")
	}
}

func TestConfigCopy_MetadataMapIndependence(t *testing.T) {
	c := &Config{
		Metadata: make(map[string]any),
	}
	got := c.Copy()
	// Verify map independence - mutations to original should not affect copy
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	// Maps are copied by value, so they should be different instances
}

func TestConfigCopy_DescriptionPointerNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Description != nil {
		t.Error("nil pointer should remain nil after copy")
	}
}

func TestConfigCopy_DescriptionPointerIndependence(t *testing.T) {
	val := "test"
	c := &Config{
		Description: &val,
	}
	got := c.Copy()
	if got.Description == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.Description == c.Description {
		t.Error("pointer should point to different memory")
	}
	if *got.Description != "test" {
		t.Errorf("expected value 'test', got %v", *got.Description)
	}
}

func TestConfigCopy_UpdatedAtPointerNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.UpdatedAt != nil {
		t.Error("nil pointer should remain nil after copy")
	}
}

func TestConfigCopy_UpdatedAtPointerIndependence(t *testing.T) {
	// Skipping detailed test for complex type time.Time - just verify pointer is copied
	orig := &Config{}
	// Set a non-nil value (implementation-dependent)
	if orig.UpdatedAt == nil {
		t.Skip("Cannot test pointer independence without setting value")
	}
	got := orig.Copy()
	if got.UpdatedAt == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.UpdatedAt == orig.UpdatedAt {
		t.Error("pointer should point to different memory")
	}
}

func TestConfigCopy_DatabaseNestedNil(t *testing.T) {
	c := &Config{}
	got := c.Copy()
	if got.Database != nil {
		t.Error("nil nested struct should remain nil after copy")
	}
}

func TestConfigCopy_DatabaseNestedIndependence(t *testing.T) {
	c := &Config{
		Database: &DatabaseConfig{},
	}
	got := c.Copy()
	if got.Database == nil {
		t.Fatal("expected nested struct to be copied")
	}
	if got.Database == c.Database {
		t.Error("nested struct should be a different pointer")
	}
}

func TestConfigCopy_MetadataDeepCopyNestedMap(t *testing.T) {
	nested := map[string]any{"inner": "value"}
	c := &Config{
		Metadata: map[string]any{"outer": nested},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify nested map in original
	nested["inner"] = "modified"
	// Verify copy is independent
	if gotOuter, ok := got.Metadata["outer"].(map[string]any); ok {
		if gotOuter["inner"] == "modified" {
			t.Error("nested map should be deep copied, not shared")
		}
	}
}

func TestConfigCopy_MetadataDeepCopyNestedSlice(t *testing.T) {
	slice := []any{"a", "b", "c"}
	c := &Config{
		Metadata: map[string]any{"list": slice},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = "modified"
	// Verify copy is independent
	if gotList, ok := got.Metadata["list"].([]any); ok {
		if gotList[0] == "modified" {
			t.Error("nested slice should be deep copied, not shared")
		}
	}
}

func TestConfigCopy_MetadataDeepCopyStringSlice(t *testing.T) {
	slice := []string{"a", "b", "c"}
	c := &Config{
		Metadata: map[string]any{"strings": slice},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = "modified"
	// Verify copy is independent
	if gotList, ok := got.Metadata["strings"].([]string); ok {
		if gotList[0] == "modified" {
			t.Error("string slice in any map should be deep copied")
		}
	}
}

func TestConfigCopy_MetadataDeepCopyIntSlice(t *testing.T) {
	slice := []int{1, 2, 3}
	c := &Config{
		Metadata: map[string]any{"ints": slice},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = 999
	// Verify copy is independent
	if gotList, ok := got.Metadata["ints"].([]int); ok {
		if gotList[0] == 999 {
			t.Error("int slice in any map should be deep copied")
		}
	}
}

func TestConfigCopy_MetadataDeepCopyNilValue(t *testing.T) {
	c := &Config{
		Metadata: map[string]any{"nil_key": nil},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	if v, exists := got.Metadata["nil_key"]; !exists || v != nil {
		t.Error("nil value in any map should be preserved")
	}
}

func TestConfigCopy_MetadataDeepCopyPrimitives(t *testing.T) {
	c := &Config{
		Metadata: map[string]any{
			"string": "test",
			"int":    42,
			"float":  3.14,
			"bool":   true,
		},
	}
	got := c.Copy()
	if got.Metadata == nil {
		t.Fatal("expected map to be copied")
	}
	if got.Metadata["string"] != "test" {
		t.Error("string value should be copied")
	}
	if got.Metadata["int"] != 42 {
		t.Error("int value should be copied")
	}
	if got.Metadata["float"] != 3.14 {
		t.Error("float value should be copied")
	}
	if got.Metadata["bool"] != true {
		t.Error("bool value should be copied")
	}
}

func TestTagCopyNil(t *testing.T) {
	var c *Tag
	got := c.Copy()
	if got != nil {
		t.Errorf("expected nil, got %v", got)
	}
}

func TestTagCopyEmpty(t *testing.T) {
	c := &Tag{}
	got := c.Copy()
	if got == nil {
		t.Fatal("expected non-nil copy")
	}
	if got == c {
		t.Error("copy should be a different pointer")
	}
}

func TestDatabaseConfigCopyNil(t *testing.T) {
	var c *DatabaseConfig
	got := c.Copy()
	if got != nil {
		t.Errorf("expected nil, got %v", got)
	}
}

func TestDatabaseConfigCopyEmpty(t *testing.T) {
	c := &DatabaseConfig{}
	got := c.Copy()
	if got == nil {
		t.Fatal("expected non-nil copy")
	}
	if got == c {
		t.Error("copy should be a different pointer")
	}
}
