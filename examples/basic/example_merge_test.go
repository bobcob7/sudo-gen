// Code generated by sudo-gen merge. DO NOT EDIT.

package basic

import (
	"testing"
)

func mergePtr[T any](v T) *T {
	return &v
}

func TestConfigApplyPartialNil(t *testing.T) {
	var c *Config
	c.ApplyPartial(nil) // should not panic

	c = &Config{}
	c.ApplyPartial(nil) // should not panic
}

func TestConfigApplyPartialEmpty(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestConfigApplyPartial_Name(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Name: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Name != "test" {
		t.Errorf("expected Name=test, got %s", c.Name)
	}
}

func TestConfigApplyPartial_NameOverwrite(t *testing.T) {
	c := &Config{Name: "original"}
	p := &ConfigPartial{Name: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Name != "updated" {
		t.Errorf("expected Name=updated, got %s", c.Name)
	}
}

func TestConfigApplyPartial_Port(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Port: mergePtr(42)}
	c.ApplyPartial(p)
	if c.Port != 42 {
		t.Errorf("expected Port=42, got %d", c.Port)
	}
}

func TestConfigApplyPartial_PortOverwrite(t *testing.T) {
	c := &Config{Port: 100}
	p := &ConfigPartial{Port: mergePtr(42)}
	c.ApplyPartial(p)
	if c.Port != 42 {
		t.Errorf("expected Port=42, got %d", c.Port)
	}
}

func TestConfigApplyPartial_PortZeroValue(t *testing.T) {
	c := &Config{Port: 100}
	p := &ConfigPartial{Port: mergePtr(0)}
	c.ApplyPartial(p)
	if c.Port != 0 {
		t.Errorf("expected Port=0 (zero value should be applied), got %d", c.Port)
	}
}

func TestConfigApplyPartial_MaxRetries(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{MaxRetries: mergePtr(int32(42))}
	c.ApplyPartial(p)
	if c.MaxRetries != 42 {
		t.Errorf("expected MaxRetries=42, got %v", c.MaxRetries)
	}
}

func TestConfigApplyPartial_Timeout(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Timeout: mergePtr(int64(42))}
	c.ApplyPartial(p)
	if c.Timeout != 42 {
		t.Errorf("expected Timeout=42, got %v", c.Timeout)
	}
}

func TestConfigApplyPartial_Rate(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Rate: mergePtr(float64(42))}
	c.ApplyPartial(p)
	if c.Rate != 42 {
		t.Errorf("expected Rate=42, got %v", c.Rate)
	}
}

func TestConfigApplyPartial_Enabled(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Enabled: mergePtr(true)}
	c.ApplyPartial(p)
	if !c.Enabled {
		t.Errorf("expected Enabled=true, got %v", c.Enabled)
	}
}

func TestConfigApplyPartial_EnabledFalse(t *testing.T) {
	c := &Config{Enabled: true}
	p := &ConfigPartial{Enabled: mergePtr(false)}
	c.ApplyPartial(p)
	if c.Enabled {
		t.Errorf("expected Enabled=false, got %v", c.Enabled)
	}
}

func TestConfigApplyPartial_HostsSlice(t *testing.T) {
	c := &Config{}
	newSlice := []string{}
	p := &ConfigPartial{Hosts: newSlice}
	c.ApplyPartial(p)
	if c.Hosts == nil {
		t.Error("expected slice to be set")
	}
}

func TestConfigApplyPartial_HostsSliceReplace(t *testing.T) {
	c := &Config{Hosts: make([]string, 2)}
	newSlice := make([]string, 3)
	p := &ConfigPartial{Hosts: newSlice}
	c.ApplyPartial(p)
	if len(c.Hosts) != 3 {
		t.Errorf("expected slice length 3, got %d", len(c.Hosts))
	}
}

func TestConfigApplyPartial_TagsSlice(t *testing.T) {
	c := &Config{}
	newSlice := []Tag{}
	p := &ConfigPartial{Tags: newSlice}
	c.ApplyPartial(p)
	if c.Tags == nil {
		t.Error("expected slice to be set")
	}
}

func TestConfigApplyPartial_TagsSliceReplace(t *testing.T) {
	c := &Config{Tags: make([]Tag, 2)}
	newSlice := make([]Tag, 3)
	p := &ConfigPartial{Tags: newSlice}
	c.ApplyPartial(p)
	if len(c.Tags) != 3 {
		t.Errorf("expected slice length 3, got %d", len(c.Tags))
	}
}

func TestConfigApplyPartial_LabelsMap(t *testing.T) {
	c := &Config{}
	m := make(map[string]string)
	p := &ConfigPartial{Labels: m}
	c.ApplyPartial(p)
	if c.Labels == nil {
		t.Error("expected map to be initialized")
	}
}

func TestConfigApplyPartial_LabelsMapMerge(t *testing.T) {
	c := &Config{Labels: make(map[string]string)}
	m := make(map[string]string)
	p := &ConfigPartial{Labels: m}
	c.ApplyPartial(p)
	if c.Labels == nil {
		t.Error("expected map to remain initialized")
	}
}

func TestConfigApplyPartial_LabelsMapWithValues(t *testing.T) {
	c := &Config{}
	m := map[string]string{"key": "value"}
	p := &ConfigPartial{Labels: m}
	c.ApplyPartial(p)
	if c.Labels == nil {
		t.Error("expected map to be initialized")
	}
	if len(c.Labels) != len(m) {
		t.Errorf("expected map length %d, got %d", len(m), len(c.Labels))
	}
}

func TestConfigApplyPartial_MetadataMap(t *testing.T) {
	c := &Config{}
	m := make(map[string]any)
	p := &ConfigPartial{Metadata: m}
	c.ApplyPartial(p)
	if c.Metadata == nil {
		t.Error("expected map to be initialized")
	}
}

func TestConfigApplyPartial_MetadataMapMerge(t *testing.T) {
	c := &Config{Metadata: make(map[string]any)}
	m := make(map[string]any)
	p := &ConfigPartial{Metadata: m}
	c.ApplyPartial(p)
	if c.Metadata == nil {
		t.Error("expected map to remain initialized")
	}
}

func TestConfigApplyPartial_MetadataMapWithValues(t *testing.T) {
	c := &Config{}
	m := map[string]any{"key": "value"}
	p := &ConfigPartial{Metadata: m}
	c.ApplyPartial(p)
	if c.Metadata == nil {
		t.Error("expected map to be initialized")
	}
	if len(c.Metadata) != len(m) {
		t.Errorf("expected map length %d, got %d", len(m), len(c.Metadata))
	}
}

func TestConfigApplyPartial_DescriptionPointer(t *testing.T) {
	c := &Config{}
	val := "test"
	p := &ConfigPartial{Description: &val}
	c.ApplyPartial(p)
	if c.Description == nil {
		t.Error("expected pointer to be set")
	}
	if *c.Description != val {
		t.Errorf("expected value %v, got %v", val, *c.Description)
	}
}

func TestConfigApplyPartial_DatabaseNestedStruct(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Database: &DatabaseConfigPartial{}}
	c.ApplyPartial(p)
	if c.Database == nil {
		t.Error("expected nested struct to be initialized")
	}
}

func TestConfigApplyPartial_DatabaseNestedStructExisting(t *testing.T) {
	c := &Config{Database: &DatabaseConfig{}}
	p := &ConfigPartial{Database: &DatabaseConfigPartial{}}
	c.ApplyPartial(p)
	if c.Database == nil {
		t.Error("expected nested struct to remain set")
	}
}

func TestTagApplyPartialNil(t *testing.T) {
	var c *Tag
	c.ApplyPartial(nil) // should not panic

	c = &Tag{}
	c.ApplyPartial(nil) // should not panic
}

func TestTagApplyPartialEmpty(t *testing.T) {
	c := &Tag{}
	p := &TagPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestTagApplyPartial_Key(t *testing.T) {
	c := &Tag{}
	p := &TagPartial{Key: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Key != "test" {
		t.Errorf("expected Key=test, got %s", c.Key)
	}
}

func TestTagApplyPartial_KeyOverwrite(t *testing.T) {
	c := &Tag{Key: "original"}
	p := &TagPartial{Key: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Key != "updated" {
		t.Errorf("expected Key=updated, got %s", c.Key)
	}
}

func TestTagApplyPartial_Value(t *testing.T) {
	c := &Tag{}
	p := &TagPartial{Value: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Value != "test" {
		t.Errorf("expected Value=test, got %s", c.Value)
	}
}

func TestTagApplyPartial_ValueOverwrite(t *testing.T) {
	c := &Tag{Value: "original"}
	p := &TagPartial{Value: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Value != "updated" {
		t.Errorf("expected Value=updated, got %s", c.Value)
	}
}

func TestDatabaseConfigApplyPartialNil(t *testing.T) {
	var c *DatabaseConfig
	c.ApplyPartial(nil) // should not panic

	c = &DatabaseConfig{}
	c.ApplyPartial(nil) // should not panic
}

func TestDatabaseConfigApplyPartialEmpty(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestDatabaseConfigApplyPartial_Host(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{Host: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Host != "test" {
		t.Errorf("expected Host=test, got %s", c.Host)
	}
}

func TestDatabaseConfigApplyPartial_HostOverwrite(t *testing.T) {
	c := &DatabaseConfig{Host: "original"}
	p := &DatabaseConfigPartial{Host: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Host != "updated" {
		t.Errorf("expected Host=updated, got %s", c.Host)
	}
}

func TestDatabaseConfigApplyPartial_Port(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{Port: mergePtr(42)}
	c.ApplyPartial(p)
	if c.Port != 42 {
		t.Errorf("expected Port=42, got %d", c.Port)
	}
}

func TestDatabaseConfigApplyPartial_PortOverwrite(t *testing.T) {
	c := &DatabaseConfig{Port: 100}
	p := &DatabaseConfigPartial{Port: mergePtr(42)}
	c.ApplyPartial(p)
	if c.Port != 42 {
		t.Errorf("expected Port=42, got %d", c.Port)
	}
}

func TestDatabaseConfigApplyPartial_PortZeroValue(t *testing.T) {
	c := &DatabaseConfig{Port: 100}
	p := &DatabaseConfigPartial{Port: mergePtr(0)}
	c.ApplyPartial(p)
	if c.Port != 0 {
		t.Errorf("expected Port=0 (zero value should be applied), got %d", c.Port)
	}
}

func TestDatabaseConfigApplyPartial_Username(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{Username: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Username != "test" {
		t.Errorf("expected Username=test, got %s", c.Username)
	}
}

func TestDatabaseConfigApplyPartial_UsernameOverwrite(t *testing.T) {
	c := &DatabaseConfig{Username: "original"}
	p := &DatabaseConfigPartial{Username: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Username != "updated" {
		t.Errorf("expected Username=updated, got %s", c.Username)
	}
}

func TestDatabaseConfigApplyPartial_Password(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{Password: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Password != "test" {
		t.Errorf("expected Password=test, got %s", c.Password)
	}
}

func TestDatabaseConfigApplyPartial_PasswordOverwrite(t *testing.T) {
	c := &DatabaseConfig{Password: "original"}
	p := &DatabaseConfigPartial{Password: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Password != "updated" {
		t.Errorf("expected Password=updated, got %s", c.Password)
	}
}

func TestDatabaseConfigApplyPartial_SSLMode(t *testing.T) {
	c := &DatabaseConfig{}
	p := &DatabaseConfigPartial{SSLMode: mergePtr("test")}
	c.ApplyPartial(p)
	if c.SSLMode != "test" {
		t.Errorf("expected SSLMode=test, got %s", c.SSLMode)
	}
}

func TestDatabaseConfigApplyPartial_SSLModeOverwrite(t *testing.T) {
	c := &DatabaseConfig{SSLMode: "original"}
	p := &DatabaseConfigPartial{SSLMode: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.SSLMode != "updated" {
		t.Errorf("expected SSLMode=updated, got %s", c.SSLMode)
	}
}
