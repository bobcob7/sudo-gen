// Code generated by sudo-gen layerbroker. DO NOT EDIT.

// ConfigLayerBroker Overview
//
// ConfigLayerBroker provides thread-safe access to Config with two key features:
//
//   - Ordered Layers: Multiple layers can apply partial updates, allowing configuration
//     to be built up from multiple sources (defaults, files, environment, flags, etc.)
//   - Field Subscriptions: Subscribe to individual field changes with type-safe callbacks
//     that fire immediately with the current value (if set) and on subsequent changes.
//
// # Creating a LayerBroker
//
// Create a new broker with an initial configuration (or nil for empty):
//
//	broker := NewConfigLayerBroker(&Config{Name: "default"})
//	// or
//	broker := NewConfigLayerBroker(nil)
//
// # Reading Configuration
//
// Get a deep copy of the current configuration:
//
//	cfg := broker.Get()
//	fmt.Println(cfg.Name)
//
// # Applying Updates with Layers
//
// Create layers to apply partial updates. Each layer can apply multiple updates
// over time, and updates are applied in the order received:
//
//	// Create a layer (e.g., for file-based config)
//	fileLayer := broker.Layer()
//	fileLayer.Set(&ConfigPartial{Name: ptr("from-file")})
//
//	// Create another layer (e.g., for environment variables)
//	envLayer := broker.Layer()
//	envLayer.Set(&ConfigPartial{Name: ptr("from-env")})
//
//	// Later updates from any layer are applied immediately
//	fileLayer.Set(&ConfigPartial{Name: ptr("updated-from-file")})
//
// # Subscribing to Field Changes
//
// Subscribe to individual fields with type-safe callbacks. The callback is invoked:
//   - Immediately with the current value (if non-zero)
//   - Whenever the field value changes
//
// The subscribe method returns an unsubscribe function:
//
//	unsub := broker.SubscribeName(func(name string) {
//	    fmt.Println("Name changed to:", name)
//	})
//	defer unsub() // Clean up when done
//
// Subscribers are only notified when the value actually changes. Setting the same
// value again does not trigger a notification.
//
// # Thread Safety
//
// All operations on ConfigLayerBroker are thread-safe. Multiple goroutines can
// safely call Get(), Layer().Set(), and Subscribe methods concurrently.
//
// Get() is lock-free using atomic pointer load, making reads very fast.
// Set() uses copy-on-write with atomic swap, ensuring readers never block.
//
// # Dependencies
//
// This generated code requires the following to also be generated:
//   - ConfigPartial (from: sudo-gen merge)
//   - Config.Copy() (from: sudo-gen copy)
package basic

import (
	"encoding/json"
	"reflect"
	"sync"
	"sync/atomic"
	"time"
)

// ConfigLayerBroker provides thread-safe access to Config with ordered layer updates and subscriptions.
type ConfigLayerBroker struct {
	base            *Config
	config          atomic.Pointer[Config]
	mu              sync.Mutex // protects subscribers, layers, and serializes writes
	nextSubID       int
	layers          []*ConfigLayer
	subsName        map[int]func(string)
	subsPort        map[int]func(int)
	subsMaxRetries  map[int]func(int32)
	subsTimeout     map[int]func(int64)
	subsRate        map[int]func(float64)
	subsEnabled     map[int]func(bool)
	subsDescription map[int]func(*string)
	subsHosts       map[int]func([]string)
	subsTags        map[int]func([]Tag)
	subsLabels      map[int]func(map[string]string)
	subsMetadata    map[int]func(map[string]any)
	subsDatabase    map[int]func(*DatabaseConfig)
	subsCreatedAt   map[int]func(time.Time)
	subsUpdatedAt   map[int]func(*time.Time)
}

// NewConfigLayerBroker creates a new LayerBroker wrapping the given config.
// If cfg is nil, an empty config is used.
func NewConfigLayerBroker(cfg *Config) *ConfigLayerBroker {
	if cfg == nil {
		cfg = &Config{}
	}
	b := &ConfigLayerBroker{
		base:            cfg.Copy(),
		subsName:        make(map[int]func(string)),
		subsPort:        make(map[int]func(int)),
		subsMaxRetries:  make(map[int]func(int32)),
		subsTimeout:     make(map[int]func(int64)),
		subsRate:        make(map[int]func(float64)),
		subsEnabled:     make(map[int]func(bool)),
		subsDescription: make(map[int]func(*string)),
		subsHosts:       make(map[int]func([]string)),
		subsTags:        make(map[int]func([]Tag)),
		subsLabels:      make(map[int]func(map[string]string)),
		subsMetadata:    make(map[int]func(map[string]any)),
		subsDatabase:    make(map[int]func(*DatabaseConfig)),
		subsCreatedAt:   make(map[int]func(time.Time)),
		subsUpdatedAt:   make(map[int]func(*time.Time)),
	}
	b.config.Store(cfg.Copy())
	return b
}

// Get returns a deep copy of the current configuration.
// This is a lock-free operation using atomic pointer load.
func (b *ConfigLayerBroker) Get() *Config {
	return b.config.Load().Copy()
}

// Layer returns a new layer for applying partial changes.
func (b *ConfigLayerBroker) Layer() *ConfigLayer {
	b.mu.Lock()
	defer b.mu.Unlock()
	l := &ConfigLayer{broker: b}
	b.layers = append(b.layers, l)
	return l
}

// SubscribeName subscribes to changes on Name.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeName(callback func(string)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsName[id] = callback
	v := b.config.Load().Name
	b.mu.Unlock()
	if v != "" {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsName, id)
	}
}

// SubscribePort subscribes to changes on Port.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribePort(callback func(int)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsPort[id] = callback
	v := b.config.Load().Port
	b.mu.Unlock()
	if v != 0 {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsPort, id)
	}
}

// SubscribeMaxRetries subscribes to changes on MaxRetries.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeMaxRetries(callback func(int32)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsMaxRetries[id] = callback
	v := b.config.Load().MaxRetries
	b.mu.Unlock()
	if v != 0 {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsMaxRetries, id)
	}
}

// SubscribeTimeout subscribes to changes on Timeout.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeTimeout(callback func(int64)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsTimeout[id] = callback
	v := b.config.Load().Timeout
	b.mu.Unlock()
	if v != 0 {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsTimeout, id)
	}
}

// SubscribeRate subscribes to changes on Rate.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeRate(callback func(float64)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsRate[id] = callback
	v := b.config.Load().Rate
	b.mu.Unlock()
	if v != 0 {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsRate, id)
	}
}

// SubscribeEnabled subscribes to changes on Enabled.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeEnabled(callback func(bool)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsEnabled[id] = callback
	v := b.config.Load().Enabled
	b.mu.Unlock()
	if v {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsEnabled, id)
	}
}

// SubscribeDescription subscribes to changes on Description.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeDescription(callback func(*string)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsDescription[id] = callback
	v := b.config.Load().Description
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsDescription, id)
	}
}

// SubscribeHosts subscribes to changes on Hosts.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeHosts(callback func([]string)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsHosts[id] = callback
	v := b.config.Load().Hosts
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsHosts, id)
	}
}

// SubscribeTags subscribes to changes on Tags.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeTags(callback func([]Tag)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsTags[id] = callback
	v := b.config.Load().Tags
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsTags, id)
	}
}

// SubscribeLabels subscribes to changes on Labels.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeLabels(callback func(map[string]string)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsLabels[id] = callback
	v := b.config.Load().Labels
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsLabels, id)
	}
}

// SubscribeMetadata subscribes to changes on Metadata.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeMetadata(callback func(map[string]any)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsMetadata[id] = callback
	v := b.config.Load().Metadata
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsMetadata, id)
	}
}

// SubscribeDatabase subscribes to changes on Database.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeDatabase(callback func(*DatabaseConfig)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsDatabase[id] = callback
	v := b.config.Load().Database
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsDatabase, id)
	}
}

// SubscribeCreatedAt subscribes to changes on CreatedAt.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeCreatedAt(callback func(time.Time)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsCreatedAt[id] = callback
	v := b.config.Load().CreatedAt
	b.mu.Unlock()
	if !v.IsZero() {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsCreatedAt, id)
	}
}

// SubscribeUpdatedAt subscribes to changes on UpdatedAt.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeUpdatedAt(callback func(*time.Time)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsUpdatedAt[id] = callback
	v := b.config.Load().UpdatedAt
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsUpdatedAt, id)
	}
}

// ConfigLayer applies partial updates to the LayerBroker.
type ConfigLayer struct {
	broker  *ConfigLayerBroker
	partial *ConfigPartial
}

// Set applies the partial and notifies subscribers for changed fields.
// Uses copy-on-write: copies the config, applies changes, then atomically swaps.
func (l *ConfigLayer) Set(p *ConfigPartial) {
	if p == nil {
		return
	}
	l.broker.mu.Lock()
	defer l.broker.mu.Unlock()
	if l.partial == nil {
		l.partial = &ConfigPartial{}
	}
	l.mergePartial(p)
	newCfg := l.broker.recompute()
	oldCfg := l.broker.config.Load()
	if old, new := oldCfg.Name, newCfg.Name; old != new {
		for _, cb := range l.broker.subsName {
			cb(new)
		}
	}
	if old, new := oldCfg.Port, newCfg.Port; old != new {
		for _, cb := range l.broker.subsPort {
			cb(new)
		}
	}
	if old, new := oldCfg.MaxRetries, newCfg.MaxRetries; old != new {
		for _, cb := range l.broker.subsMaxRetries {
			cb(new)
		}
	}
	if old, new := oldCfg.Timeout, newCfg.Timeout; old != new {
		for _, cb := range l.broker.subsTimeout {
			cb(new)
		}
	}
	if old, new := oldCfg.Rate, newCfg.Rate; old != new {
		for _, cb := range l.broker.subsRate {
			cb(new)
		}
	}
	if old, new := oldCfg.Enabled, newCfg.Enabled; old != new {
		for _, cb := range l.broker.subsEnabled {
			cb(new)
		}
	}
	if old, new := oldCfg.Description, newCfg.Description; (old == nil) != (new == nil) || (old != nil && *old != *new) {
		for _, cb := range l.broker.subsDescription {
			cb(new)
		}
	}
	if old, new := oldCfg.Hosts, newCfg.Hosts; !reflect.DeepEqual(old, new) {
		for _, cb := range l.broker.subsHosts {
			cb(new)
		}
	}
	if old, new := oldCfg.Tags, newCfg.Tags; !reflect.DeepEqual(old, new) {
		for _, cb := range l.broker.subsTags {
			cb(new)
		}
	}
	if old, new := oldCfg.Labels, newCfg.Labels; !reflect.DeepEqual(old, new) {
		for _, cb := range l.broker.subsLabels {
			cb(new)
		}
	}
	if old, new := oldCfg.Metadata, newCfg.Metadata; !reflect.DeepEqual(old, new) {
		for _, cb := range l.broker.subsMetadata {
			cb(new)
		}
	}
	if old, new := oldCfg.CreatedAt, newCfg.CreatedAt; !old.Equal(new) {
		for _, cb := range l.broker.subsCreatedAt {
			cb(new)
		}
	}
	if old, new := oldCfg.UpdatedAt, newCfg.UpdatedAt; (old == nil) != (new == nil) || (old != nil && *old != *new) {
		for _, cb := range l.broker.subsUpdatedAt {
			cb(new)
		}
	}
	l.broker.config.Store(newCfg)
}

// mergePartial merges the given partial into the layer's accumulated partial.
func (l *ConfigLayer) mergePartial(p *ConfigPartial) {
	if p.Name != nil {
		l.partial.Name = p.Name
	}
	if p.Port != nil {
		l.partial.Port = p.Port
	}
	if p.MaxRetries != nil {
		l.partial.MaxRetries = p.MaxRetries
	}
	if p.Timeout != nil {
		l.partial.Timeout = p.Timeout
	}
	if p.Rate != nil {
		l.partial.Rate = p.Rate
	}
	if p.Enabled != nil {
		l.partial.Enabled = p.Enabled
	}
	if p.Description != nil {
		l.partial.Description = p.Description
	}
	if p.Hosts != nil {
		l.partial.Hosts = p.Hosts
	}
	if p.Tags != nil {
		l.partial.Tags = p.Tags
	}
	if p.Labels != nil {
		l.partial.Labels = p.Labels
	}
	if p.Metadata != nil {
		l.partial.Metadata = p.Metadata
	}
	if p.Database != nil {
		l.partial.Database = p.Database
	}
	if p.CreatedAt != nil {
		l.partial.CreatedAt = p.CreatedAt
	}
	if p.UpdatedAt != nil {
		l.partial.UpdatedAt = p.UpdatedAt
	}
}

// recompute rebuilds the config from base and all layer partials.
func (b *ConfigLayerBroker) recompute() *Config {
	cfg := b.base.Copy()
	for _, layer := range b.layers {
		if layer.partial != nil {
			cfg.ApplyPartial(layer.partial)
		}
	}
	return cfg
}

// ConfigLayerBrokerState represents the serializable state of the broker.
type ConfigLayerBrokerState struct {
	Base   *Config          `json:"base"`
	Layers []*ConfigPartial `json:"layers"`
	Final  *Config          `json:"final"`
}

// MarshalJSON serializes the broker state including base config, all layer partials, and final merged config.
func (b *ConfigLayerBroker) MarshalJSON() ([]byte, error) {
	b.mu.Lock()
	defer b.mu.Unlock()
	layers := make([]*ConfigPartial, 0, len(b.layers))
	for _, layer := range b.layers {
		layers = append(layers, layer.partial)
	}
	state := ConfigLayerBrokerState{
		Base:   b.base,
		Layers: layers,
		Final:  b.config.Load(),
	}
	return json.Marshal(state)
}
