// Code generated by sudo-gen merge. DO NOT EDIT.

package nested

import (
	"testing"
)

func mergePtr[T any](v T) *T {
	return &v
}

func TestConfigApplyPartialNil(t *testing.T) {
	var c *Config
	c.ApplyPartial(nil) // should not panic

	c = &Config{}
	c.ApplyPartial(nil) // should not panic
}

func TestConfigApplyPartialEmpty(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestConfigApplyPartial_Name(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{Name: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Name != "test" {
		t.Errorf("expected Name=test, got %s", c.Name)
	}
}

func TestConfigApplyPartial_NameOverwrite(t *testing.T) {
	c := &Config{Name: "original"}
	p := &ConfigPartial{Name: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Name != "updated" {
		t.Errorf("expected Name=updated, got %s", c.Name)
	}
}

func TestConfigApplyPartial_JobsSlice(t *testing.T) {
	c := &Config{}
	newSlice := []Job{}
	p := &ConfigPartial{Jobs: newSlice}
	c.ApplyPartial(p)
	if c.Jobs == nil {
		t.Error("expected slice to be set")
	}
}

func TestConfigApplyPartial_JobsSliceReplace(t *testing.T) {
	c := &Config{Jobs: make([]Job, 2)}
	newSlice := make([]Job, 3)
	p := &ConfigPartial{Jobs: newSlice}
	c.ApplyPartial(p)
	if len(c.Jobs) != 3 {
		t.Errorf("expected slice length 3, got %d", len(c.Jobs))
	}
}

func TestConfigApplyPartial_OtherHomeNestedStruct(t *testing.T) {
	c := &Config{}
	p := &ConfigPartial{OtherHome: &HomePartial{}}
	c.ApplyPartial(p)
	if c.OtherHome == nil {
		t.Error("expected nested struct to be initialized")
	}
}

func TestConfigApplyPartial_OtherHomeNestedStructExisting(t *testing.T) {
	c := &Config{OtherHome: &Home{}}
	p := &ConfigPartial{OtherHome: &HomePartial{}}
	c.ApplyPartial(p)
	if c.OtherHome == nil {
		t.Error("expected nested struct to remain set")
	}
}

func TestJobApplyPartialNil(t *testing.T) {
	var c *Job
	c.ApplyPartial(nil) // should not panic

	c = &Job{}
	c.ApplyPartial(nil) // should not panic
}

func TestJobApplyPartialEmpty(t *testing.T) {
	c := &Job{}
	p := &JobPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestJobApplyPartial_Title(t *testing.T) {
	c := &Job{}
	p := &JobPartial{Title: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Title != "test" {
		t.Errorf("expected Title=test, got %s", c.Title)
	}
}

func TestJobApplyPartial_TitleOverwrite(t *testing.T) {
	c := &Job{Title: "original"}
	p := &JobPartial{Title: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Title != "updated" {
		t.Errorf("expected Title=updated, got %s", c.Title)
	}
}

func TestJobApplyPartial_Company(t *testing.T) {
	c := &Job{}
	p := &JobPartial{Company: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Company != "test" {
		t.Errorf("expected Company=test, got %s", c.Company)
	}
}

func TestJobApplyPartial_CompanyOverwrite(t *testing.T) {
	c := &Job{Company: "original"}
	p := &JobPartial{Company: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Company != "updated" {
		t.Errorf("expected Company=updated, got %s", c.Company)
	}
}

func TestJobApplyPartial_Location(t *testing.T) {
	c := &Job{}
	p := &JobPartial{Location: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Location != "test" {
		t.Errorf("expected Location=test, got %s", c.Location)
	}
}

func TestJobApplyPartial_LocationOverwrite(t *testing.T) {
	c := &Job{Location: "original"}
	p := &JobPartial{Location: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Location != "updated" {
		t.Errorf("expected Location=updated, got %s", c.Location)
	}
}

func TestJobApplyPartial_CoordsNestedStruct(t *testing.T) {
	c := &Job{}
	p := &JobPartial{Coords: &CoordinatesPartial{}}
	c.ApplyPartial(p)
	if c.Coords == nil {
		t.Error("expected nested struct to be initialized")
	}
}

func TestJobApplyPartial_CoordsNestedStructExisting(t *testing.T) {
	c := &Job{Coords: &Coordinates{}}
	p := &JobPartial{Coords: &CoordinatesPartial{}}
	c.ApplyPartial(p)
	if c.Coords == nil {
		t.Error("expected nested struct to remain set")
	}
}

func TestCoordinatesApplyPartialNil(t *testing.T) {
	var c *Coordinates
	c.ApplyPartial(nil) // should not panic

	c = &Coordinates{}
	c.ApplyPartial(nil) // should not panic
}

func TestCoordinatesApplyPartialEmpty(t *testing.T) {
	c := &Coordinates{}
	p := &CoordinatesPartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestCoordinatesApplyPartial_Latitude(t *testing.T) {
	c := &Coordinates{}
	p := &CoordinatesPartial{Latitude: mergePtr(float64(42))}
	c.ApplyPartial(p)
	if c.Latitude != 42 {
		t.Errorf("expected Latitude=42, got %v", c.Latitude)
	}
}

func TestCoordinatesApplyPartial_Longitude(t *testing.T) {
	c := &Coordinates{}
	p := &CoordinatesPartial{Longitude: mergePtr(float64(42))}
	c.ApplyPartial(p)
	if c.Longitude != 42 {
		t.Errorf("expected Longitude=42, got %v", c.Longitude)
	}
}

func TestHomeApplyPartialNil(t *testing.T) {
	var c *Home
	c.ApplyPartial(nil) // should not panic

	c = &Home{}
	c.ApplyPartial(nil) // should not panic
}

func TestHomeApplyPartialEmpty(t *testing.T) {
	c := &Home{}
	p := &HomePartial{}
	c.ApplyPartial(p) // should not panic or change anything
}

func TestHomeApplyPartial_Address(t *testing.T) {
	c := &Home{}
	p := &HomePartial{Address: mergePtr("test")}
	c.ApplyPartial(p)
	if c.Address != "test" {
		t.Errorf("expected Address=test, got %s", c.Address)
	}
}

func TestHomeApplyPartial_AddressOverwrite(t *testing.T) {
	c := &Home{Address: "original"}
	p := &HomePartial{Address: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.Address != "updated" {
		t.Errorf("expected Address=updated, got %s", c.Address)
	}
}

func TestHomeApplyPartial_City(t *testing.T) {
	c := &Home{}
	p := &HomePartial{City: mergePtr("test")}
	c.ApplyPartial(p)
	if c.City != "test" {
		t.Errorf("expected City=test, got %s", c.City)
	}
}

func TestHomeApplyPartial_CityOverwrite(t *testing.T) {
	c := &Home{City: "original"}
	p := &HomePartial{City: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.City != "updated" {
		t.Errorf("expected City=updated, got %s", c.City)
	}
}

func TestHomeApplyPartial_ZipCode(t *testing.T) {
	c := &Home{}
	p := &HomePartial{ZipCode: mergePtr("test")}
	c.ApplyPartial(p)
	if c.ZipCode != "test" {
		t.Errorf("expected ZipCode=test, got %s", c.ZipCode)
	}
}

func TestHomeApplyPartial_ZipCodeOverwrite(t *testing.T) {
	c := &Home{ZipCode: "original"}
	p := &HomePartial{ZipCode: mergePtr("updated")}
	c.ApplyPartial(p)
	if c.ZipCode != "updated" {
		t.Errorf("expected ZipCode=updated, got %s", c.ZipCode)
	}
}

func TestHomeApplyPartial_DestinationNestedStruct(t *testing.T) {
	c := &Home{}
	p := &HomePartial{Destination: &CoordinatesPartial{}}
	c.ApplyPartial(p)
	if c.Destination == nil {
		t.Error("expected nested struct to be initialized")
	}
}

func TestHomeApplyPartial_DestinationNestedStructExisting(t *testing.T) {
	c := &Home{Destination: &Coordinates{}}
	p := &HomePartial{Destination: &CoordinatesPartial{}}
	c.ApplyPartial(p)
	if c.Destination == nil {
		t.Error("expected nested struct to remain set")
	}
}
