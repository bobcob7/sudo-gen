// Code generated by sudo-gen layerbroker. DO NOT EDIT.

// ConfigLayerBroker Overview
//
// ConfigLayerBroker provides thread-safe access to Config with two key features:
//
//   - Ordered Layers: Multiple layers can apply partial updates, allowing configuration
//     to be built up from multiple sources (defaults, files, environment, flags, etc.)
//   - Field Subscriptions: Subscribe to individual field changes with type-safe callbacks
//     that fire immediately with the current value (if set) and on subsequent changes.
//
// # Creating a LayerBroker
//
// Create a new broker with an initial configuration (or nil for empty):
//
//	broker := NewConfigLayerBroker(&Config{Name: "default"})
//	// or
//	broker := NewConfigLayerBroker(nil)
//
// # Reading Configuration
//
// Get a deep copy of the current configuration:
//
//	cfg := broker.Get()
//	fmt.Println(cfg.Name)
//
// # Applying Updates with Layers
//
// Create layers to apply partial updates. Each layer can apply multiple updates
// over time, and updates are applied in the order received:
//
//	// Create a layer (e.g., for file-based config)
//	fileLayer := broker.Layer()
//	fileLayer.Set(&ConfigPartial{Name: ptr("from-file")})
//
//	// Create another layer (e.g., for environment variables)
//	envLayer := broker.Layer()
//	envLayer.Set(&ConfigPartial{Name: ptr("from-env")})
//
//	// Later updates from any layer are applied immediately
//	fileLayer.Set(&ConfigPartial{Name: ptr("updated-from-file")})
//
// # Subscribing to Field Changes
//
// Subscribe to individual fields with type-safe callbacks. The callback is invoked:
//   - Immediately with the current value (if non-zero)
//   - Whenever the field value changes
//
// The subscribe method returns an unsubscribe function:
//
//	unsub := broker.SubscribeName(func(name string) {
//	    fmt.Println("Name changed to:", name)
//	})
//	defer unsub() // Clean up when done
//
// Subscribers are only notified when the value actually changes. Setting the same
// value again does not trigger a notification.
//
// # Thread Safety
//
// All operations on ConfigLayerBroker are thread-safe. Multiple goroutines can
// safely call Get(), Layer().Set(), and Subscribe methods concurrently.
//
// Get() is lock-free using atomic pointer load, making reads very fast.
// Set() uses copy-on-write with atomic swap, ensuring readers never block.
//
// # Dependencies
//
// This generated code requires the following to also be generated:
//   - ConfigPartial (from: sudo-gen merge)
//   - Config.Copy() (from: sudo-gen copy)
package nested

import (
	"encoding/json"
	"sync"
	"sync/atomic"
	"time"
)

// ConfigLayerBroker provides thread-safe access to Config with ordered layer updates and subscriptions.
type ConfigLayerBroker struct {
	base          *Config
	config        atomic.Pointer[Config]
	mu            sync.Mutex // protects subscribers, layers, and serializes writes
	nextSubID     int
	layers        []*ConfigLayer
	subsName      map[int]func(string)
	subsJobs      map[int]func([]Job)
	subsHome      map[int]func(Home)
	subsOtherHome map[int]func(*Home)
	subsCreatedAt map[int]func(time.Time)
}

// NewConfigLayerBroker creates a new LayerBroker wrapping the given config.
// If cfg is nil, an empty config is used.
func NewConfigLayerBroker(cfg *Config) *ConfigLayerBroker {
	if cfg == nil {
		cfg = &Config{}
	}
	b := &ConfigLayerBroker{
		base:          cfg.Copy(),
		subsName:      make(map[int]func(string)),
		subsJobs:      make(map[int]func([]Job)),
		subsHome:      make(map[int]func(Home)),
		subsOtherHome: make(map[int]func(*Home)),
		subsCreatedAt: make(map[int]func(time.Time)),
	}
	b.config.Store(cfg.Copy())
	return b
}

// Get returns a deep copy of the current configuration.
// This is a lock-free operation using atomic pointer load.
func (b *ConfigLayerBroker) Get() *Config {
	return b.config.Load().Copy()
}

// Layer returns a new layer for applying partial changes.
func (b *ConfigLayerBroker) Layer() *ConfigLayer {
	b.mu.Lock()
	defer b.mu.Unlock()
	l := &ConfigLayer{broker: b}
	b.layers = append(b.layers, l)
	return l
}

// SubscribeName subscribes to changes on Name.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeName(callback func(string)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsName[id] = callback
	v := b.config.Load().Name
	b.mu.Unlock()
	if v != "" {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsName, id)
	}
}

// SubscribeJobs subscribes to changes on Jobs.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeJobs(callback func([]Job)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsJobs[id] = callback
	v := b.config.Load().Jobs
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsJobs, id)
	}
}

// SubscribeHome subscribes to changes on Home.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeHome(callback func(Home)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsHome[id] = callback
	v := b.config.Load().Home
	b.mu.Unlock()
	callback(v)
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsHome, id)
	}
}

// SubscribeOtherHome subscribes to changes on OtherHome.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeOtherHome(callback func(*Home)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsOtherHome[id] = callback
	v := b.config.Load().OtherHome
	b.mu.Unlock()
	if v != nil {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsOtherHome, id)
	}
}

// SubscribeCreatedAt subscribes to changes on CreatedAt.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *ConfigLayerBroker) SubscribeCreatedAt(callback func(time.Time)) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subsCreatedAt[id] = callback
	v := b.config.Load().CreatedAt
	b.mu.Unlock()
	if !v.IsZero() {
		callback(v)
	}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subsCreatedAt, id)
	}
}

// ConfigLayer applies partial updates to the LayerBroker.
type ConfigLayer struct {
	broker  *ConfigLayerBroker
	partial *ConfigPartial
}

// Set applies the partial and notifies subscribers for changed fields.
// Uses copy-on-write: copies the config, applies changes, then atomically swaps.
func (l *ConfigLayer) Set(p *ConfigPartial) {
	if p == nil {
		return
	}
	l.broker.mu.Lock()
	defer l.broker.mu.Unlock()
	if l.partial == nil {
		l.partial = &ConfigPartial{}
	}
	l.mergePartial(p)
	newCfg := l.broker.recompute()
	oldCfg := l.broker.config.Load()
	if old, new := oldCfg.Name, newCfg.Name; !configEqualName(old, new) {
		for _, cb := range l.broker.subsName {
			cb(new)
		}
	}
	if old, new := oldCfg.Jobs, newCfg.Jobs; !configEqualJobs(old, new) {
		for _, cb := range l.broker.subsJobs {
			cb(new)
		}
	}
	if old, new := oldCfg.Home, newCfg.Home; !configEqualHome(old, new) {
		for _, cb := range l.broker.subsHome {
			cb(new)
		}
	}
	if old, new := oldCfg.CreatedAt, newCfg.CreatedAt; !configEqualCreatedAt(old, new) {
		for _, cb := range l.broker.subsCreatedAt {
			cb(new)
		}
	}
	l.broker.config.Store(newCfg)
}
func configEqualName(a, b string) bool {
	return a == b
}
func configEqualJobs(a, b []Job) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if !a[i].Equal(&b[i]) {
			return false
		}
	}
	return true
}
func configEqualHome(a, b Home) bool {
	return a.Equal(&b)
}
func configEqualCreatedAt(a, b time.Time) bool {
	return a.Equal(b)
}

// mergePartial merges the given partial into the layer's accumulated partial.
func (l *ConfigLayer) mergePartial(p *ConfigPartial) {
	if p.Name != nil {
		l.partial.Name = p.Name
	}
	if p.Jobs != nil {
		l.partial.Jobs = p.Jobs
	}
	if p.Home != nil {
		l.partial.Home = p.Home
	}
	if p.OtherHome != nil {
		l.partial.OtherHome = p.OtherHome
	}
	if p.CreatedAt != nil {
		l.partial.CreatedAt = p.CreatedAt
	}
}

// recompute rebuilds the config from base and all layer partials.
func (b *ConfigLayerBroker) recompute() *Config {
	cfg := b.base.Copy()
	for _, layer := range b.layers {
		if layer.partial != nil {
			cfg.ApplyPartial(layer.partial)
		}
	}
	return cfg
}

// ConfigLayerBrokerState represents the serializable state of the broker.
type ConfigLayerBrokerState struct {
	Base   *Config          `json:"base"`
	Layers []*ConfigPartial `json:"layers"`
	Final  *Config          `json:"final"`
}

// MarshalJSON serializes the broker state including base config, all layer partials, and final merged config.
func (b *ConfigLayerBroker) MarshalJSON() ([]byte, error) {
	b.mu.Lock()
	defer b.mu.Unlock()
	layers := make([]*ConfigPartial, 0, len(b.layers))
	for _, layer := range b.layers {
		layers = append(layers, layer.partial)
	}
	state := ConfigLayerBrokerState{
		Base:   b.base,
		Layers: layers,
		Final:  b.config.Load(),
	}
	return json.Marshal(state)
}
