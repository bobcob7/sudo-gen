package copy

const copyTemplate = `// Code generated by sudo-gen copy. DO NOT EDIT.

package {{.Package}}

{{if .Imports -}}
import (
{{range .Imports}}	{{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
{{end}})

{{end -}}
// {{.MethodName}} creates a deep copy of the {{.TypeName}}.
func (c *{{.TypeName}}) {{.MethodName}}() *{{.TypeName}} {
	if c == nil {
		return nil
	}
	dst := &{{.TypeName}}{}
{{- range .Fields}}
{{- if .IsPointer}}
{{- if .StructTypeName}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = c.{{.Name}}.{{$.MethodName}}()
	}
{{- else}}
	if c.{{.Name}} != nil {
		v := *c.{{.Name}}
		dst.{{.Name}} = &v
	}
{{- end}}
{{- else if .IsSlice}}
{{- if .NeedsDeep}}
{{- if .SliceElemIsPtr}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for i, v := range c.{{.Name}} {
			dst.{{.Name}}[i] = v.{{$.MethodName}}()
		}
	}
{{- else if .StructTypeName}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for i := range c.{{.Name}} {
			dst.{{.Name}}[i] = *c.{{.Name}}[i].{{$.MethodName}}()
		}
	}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else if .IsMap}}
{{- if .NeedsDeep}}
{{- if and .StructTypeName (not (eq .ValueType "any"))}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for k, v := range c.{{.Name}} {
			dst.{{.Name}}[k] = *v.{{$.MethodName}}()
		}
	}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for k, v := range c.{{.Name}} {
			dst.{{.Name}}[k] = deepCopy{{$.TypeName}}Any(v)
		}
	}
{{- end}}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		maps.Copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else if .IsStruct}}
{{- if .StructTypeName}}
	dst.{{.Name}} = *c.{{.Name}}.{{$.MethodName}}()
{{- else}}
	dst.{{.Name}} = c.{{.Name}}
{{- end}}
{{- else}}
	dst.{{.Name}} = c.{{.Name}}
{{- end}}
{{- end}}
	return dst
}
{{range .Fields}}{{if and .IsMap .NeedsDeep (not .StructTypeName)}}
func deepCopy{{$.TypeName}}Any(v any) any {
	if v == nil {
		return nil
	}
	switch val := v.(type) {
	case map[string]any:
		m := make(map[string]any, len(val))
		for k, v := range val {
			m[k] = deepCopy{{$.TypeName}}Any(v)
		}
		return m
	case []any:
		s := make([]any, len(val))
		for i, v := range val {
			s[i] = deepCopy{{$.TypeName}}Any(v)
		}
		return s
	case []string:
		s := make([]string, len(val))
		copy(s, val)
		return s
	case []int:
		s := make([]int, len(val))
		copy(s, val)
		return s
	default:
		return val
	}
}
{{break}}{{end}}{{end}}
{{- range .NestedTypes}}

func (c *{{.TypeName}}) {{.MethodName}}() *{{.TypeName}} {
	if c == nil {
		return nil
	}
	dst := &{{.TypeName}}{}
{{- range .Fields}}
{{- if .IsPointer}}
{{- if .StructTypeName}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = c.{{.Name}}.{{$.MethodName}}()
	}
{{- else}}
	if c.{{.Name}} != nil {
		v := *c.{{.Name}}
		dst.{{.Name}} = &v
	}
{{- end}}
{{- else if .IsSlice}}
{{- if .NeedsDeep}}
{{- if .SliceElemIsPtr}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for i, v := range c.{{.Name}} {
			dst.{{.Name}}[i] = v.{{$.MethodName}}()
		}
	}
{{- else if .StructTypeName}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for i := range c.{{.Name}} {
			dst.{{.Name}}[i] = *c.{{.Name}}[i].{{$.MethodName}}()
		}
	}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else if .IsMap}}
{{- if .NeedsDeep}}
{{- if and .StructTypeName (not (eq .ValueType "any"))}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for k, v := range c.{{.Name}} {
			dst.{{.Name}}[k] = *v.{{$.MethodName}}()
		}
	}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		for k, v := range c.{{.Name}} {
			dst.{{.Name}}[k] = deepCopy{{$.TypeName}}Any(v)
		}
	}
{{- end}}
{{- else}}
	if c.{{.Name}} != nil {
		dst.{{.Name}} = make({{.Type}}, len(c.{{.Name}}))
		maps.Copy(dst.{{.Name}}, c.{{.Name}})
	}
{{- end}}
{{- else if .IsStruct}}
{{- if .StructTypeName}}
	dst.{{.Name}} = *c.{{.Name}}.{{$.MethodName}}()
{{- else}}
	dst.{{.Name}} = c.{{.Name}}
{{- end}}
{{- else}}
	dst.{{.Name}} = c.{{.Name}}
{{- end}}
{{- end}}
	return dst
}
{{- end}}
`

const copyTestTemplate = `// Code generated by sudo-gen copy. DO NOT EDIT.

package {{.Package}}

import (
	"testing"
)

func Test{{.TypeName}}{{.MethodName}}Nil(t *testing.T) {
	var c *{{.TypeName}}
	got := c.{{.MethodName}}()
	if got != nil {
		t.Errorf("expected nil, got %v", got)
	}
}

func Test{{.TypeName}}{{.MethodName}}Empty(t *testing.T) {
	c := &{{.TypeName}}{}
	got := c.{{.MethodName}}()
	if got == nil {
		t.Fatal("expected non-nil copy")
	}
	if got == c {
		t.Error("copy should be a different pointer")
	}
}

func Test{{.TypeName}}{{.MethodName}}Independence(t *testing.T) {
	c := &{{.TypeName}}{}
	got := c.{{.MethodName}}()

	// Modify original - copy should not change
	// This is a basic test; manual verification recommended for complex types
	if got == c {
		t.Error("copy should be independent from original")
	}
}
{{range .Fields}}{{if .IsSlice}}
func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}Slice(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: make({{.Type}}, 2),
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected slice to be copied")
	}
	if len(got.{{.Name}}) != len(c.{{.Name}}) {
		t.Errorf("expected len %d, got %d", len(c.{{.Name}}), len(got.{{.Name}}))
	}
	// Verify independence by checking slice headers differ
	if len(c.{{.Name}}) > 0 && &got.{{.Name}}[0] == &c.{{.Name}}[0] {
		t.Error("slice should be a deep copy, not share backing array")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}SliceNil(t *testing.T) {
	c := &{{$.TypeName}}{}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} != nil {
		t.Error("nil slice should remain nil after copy")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}SliceIndependence(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: make({{.Type}}, 1),
	}
	got := c.{{$.MethodName}}()
	if len(c.{{.Name}}) == 0 {
		t.Skip("slice has no elements to test")
	}
	// Original slice length should not affect copy length
	originalLen := len(c.{{.Name}})
	c.{{.Name}} = append(c.{{.Name}}, c.{{.Name}}[0])
	if len(got.{{.Name}}) != originalLen {
		t.Error("modifications to original slice should not affect copy")
	}
}
{{end}}{{end}}
{{range .Fields}}{{if .IsMap}}
func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}Map(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: make({{.Type}}),
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}MapNil(t *testing.T) {
	c := &{{$.TypeName}}{}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} != nil {
		t.Error("nil map should remain nil after copy")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}MapIndependence(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: make({{.Type}}),
	}
	got := c.{{$.MethodName}}()
	// Verify map independence - mutations to original should not affect copy
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	// Maps are copied by value, so they should be different instances
}
{{end}}{{end}}
{{range .Fields}}{{if and .IsPointer (not .StructTypeName)}}
func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}PointerNil(t *testing.T) {
	c := &{{$.TypeName}}{}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} != nil {
		t.Error("nil pointer should remain nil after copy")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}PointerIndependence(t *testing.T) {
	{{- if eq .ElemType "string"}}
	val := "test"
	c := &{{$.TypeName}}{
		{{.Name}}: &val,
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.{{.Name}} == c.{{.Name}} {
		t.Error("pointer should point to different memory")
	}
	if *got.{{.Name}} != "test" {
		t.Errorf("expected value 'test', got %v", *got.{{.Name}})
	}
	{{- else if or (eq .ElemType "int") (eq .ElemType "int32") (eq .ElemType "int64")}}
	val := {{.ElemType}}(42)
	c := &{{$.TypeName}}{
		{{.Name}}: &val,
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.{{.Name}} == c.{{.Name}} {
		t.Error("pointer should point to different memory")
	}
	// Modify original should not affect copy
	*c.{{.Name}} = 999
	if *got.{{.Name}} == 999 {
		t.Error("modifications to original should not affect copy")
	}
	{{- else if or (eq .ElemType "float32") (eq .ElemType "float64")}}
	val := {{.ElemType}}(3.14)
	c := &{{$.TypeName}}{
		{{.Name}}: &val,
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.{{.Name}} == c.{{.Name}} {
		t.Error("pointer should point to different memory")
	}
	// Modify original should not affect copy
	*c.{{.Name}} = 999.0
	if *got.{{.Name}} == 999.0 {
		t.Error("modifications to original should not affect copy")
	}
	{{- else if eq .ElemType "bool"}}
	val := true
	c := &{{$.TypeName}}{
		{{.Name}}: &val,
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.{{.Name}} == c.{{.Name}} {
		t.Error("pointer should point to different memory")
	}
	{{- else}}
	// Skipping detailed test for complex type {{.ElemType}} - just verify pointer is copied
	orig := &{{$.TypeName}}{}
	// Set a non-nil value (implementation-dependent)
	if orig.{{.Name}} == nil {
		t.Skip("Cannot test pointer independence without setting value")
	}
	got := orig.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected pointer to be copied")
	}
	if got.{{.Name}} == orig.{{.Name}} {
		t.Error("pointer should point to different memory")
	}
	{{- end}}
}
{{end}}{{end}}
{{range .Fields}}{{if and .IsPointer .StructTypeName}}
func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}NestedNil(t *testing.T) {
	c := &{{$.TypeName}}{}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} != nil {
		t.Error("nil nested struct should remain nil after copy")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}NestedIndependence(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: &{{.StructTypeName}}{},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected nested struct to be copied")
	}
	if got.{{.Name}} == c.{{.Name}} {
		t.Error("nested struct should be a different pointer")
	}
}
{{end}}{{end}}
{{range .Fields}}{{if and .IsMap .NeedsDeep (eq .ValueType "any")}}
func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyNestedMap(t *testing.T) {
	nested := map[string]any{"inner": "value"}
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{"outer": nested},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify nested map in original
	nested["inner"] = "modified"
	// Verify copy is independent
	if gotOuter, ok := got.{{.Name}}["outer"].(map[string]any); ok {
		if gotOuter["inner"] == "modified" {
			t.Error("nested map should be deep copied, not shared")
		}
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyNestedSlice(t *testing.T) {
	slice := []any{"a", "b", "c"}
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{"list": slice},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = "modified"
	// Verify copy is independent
	if gotList, ok := got.{{.Name}}["list"].([]any); ok {
		if gotList[0] == "modified" {
			t.Error("nested slice should be deep copied, not shared")
		}
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyStringSlice(t *testing.T) {
	slice := []string{"a", "b", "c"}
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{"strings": slice},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = "modified"
	// Verify copy is independent
	if gotList, ok := got.{{.Name}}["strings"].([]string); ok {
		if gotList[0] == "modified" {
			t.Error("string slice in any map should be deep copied")
		}
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyIntSlice(t *testing.T) {
	slice := []int{1, 2, 3}
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{"ints": slice},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	// Modify slice in original
	slice[0] = 999
	// Verify copy is independent
	if gotList, ok := got.{{.Name}}["ints"].([]int); ok {
		if gotList[0] == 999 {
			t.Error("int slice in any map should be deep copied")
		}
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyNilValue(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{"nil_key": nil},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	if v, exists := got.{{.Name}}["nil_key"]; !exists || v != nil {
		t.Error("nil value in any map should be preserved")
	}
}

func Test{{$.TypeName}}{{$.MethodName}}_{{.Name}}DeepCopyPrimitives(t *testing.T) {
	c := &{{$.TypeName}}{
		{{.Name}}: map[string]any{
			"string":  "test",
			"int":     42,
			"float":   3.14,
			"bool":    true,
		},
	}
	got := c.{{$.MethodName}}()
	if got.{{.Name}} == nil {
		t.Fatal("expected map to be copied")
	}
	if got.{{.Name}}["string"] != "test" {
		t.Error("string value should be copied")
	}
	if got.{{.Name}}["int"] != 42 {
		t.Error("int value should be copied")
	}
	if got.{{.Name}}["float"] != 3.14 {
		t.Error("float value should be copied")
	}
	if got.{{.Name}}["bool"] != true {
		t.Error("bool value should be copied")
	}
}
{{break}}{{end}}{{end}}
{{range .NestedTypes}}
func Test{{.TypeName}}{{.MethodName}}Nil(t *testing.T) {
	var c *{{.TypeName}}
	got := c.{{.MethodName}}()
	if got != nil {
		t.Errorf("expected nil, got %v", got)
	}
}

func Test{{.TypeName}}{{.MethodName}}Empty(t *testing.T) {
	c := &{{.TypeName}}{}
	got := c.{{.MethodName}}()
	if got == nil {
		t.Fatal("expected non-nil copy")
	}
	if got == c {
		t.Error("copy should be a different pointer")
	}
}
{{end}}
`
