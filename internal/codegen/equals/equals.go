// Package equals implements the equals code generation subtool.
package equals

import (
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/bobcob7/merge-config/internal/codegen"
)

// Subtool implements the equals code generator.
type Subtool struct {
	MethodName string
}

// Name returns the subtool name.
func (s *Subtool) Name() string { return "equals" }

// Description returns the subtool description.
func (s *Subtool) Description() string {
	return "Generate type-safe equality comparison methods for structs"
}

// Run executes the equals code generation.
func (s *Subtool) Run(cfg codegen.GeneratorConfig) error {
	methodName := s.MethodName
	if methodName == "" {
		methodName = "Equal"
	}
	info, err := codegen.ParseStruct(cfg.SourceDir, cfg.SourceFile, cfg.TypeName)
	if err != nil {
		return fmt.Errorf("parsing struct: %w", err)
	}
	nested, err := codegen.FindNestedStructs(cfg.SourceDir, cfg.SourceFile, info)
	if err != nil {
		return fmt.Errorf("finding nested structs: %w", err)
	}
	allStructs := append([]*codegen.StructInfo{info}, nested...)
	return generateEqualsFile(cfg, allStructs, methodName)
}

func generateEqualsFile(cfg codegen.GeneratorConfig, structs []*codegen.StructInfo, methodName string) error {
	baseName := strings.TrimSuffix(cfg.SourceFile, ".go")
	outputFile := filepath.Join(cfg.OutputDir, baseName+"_equals.go")
	data := templateData{
		Package:    cfg.OutputPkg,
		Structs:    structs,
		MethodName: methodName,
	}
	gen := codegen.NewTemplateGenerator(templateFuncs())
	return gen.GenerateFile(outputFile, equalsTemplate, data)
}

type templateData struct {
	Package    string
	Structs    []*codegen.StructInfo
	MethodName string
}

func templateFuncs() template.FuncMap {
	return template.FuncMap{
		"isLocalStruct": isLocalStruct,
	}
}

func isLocalStruct(f codegen.FieldInfo) bool {
	return f.IsStruct && f.TypePkg == "" && !f.IsSlice && !f.IsMap
}

const equalsTemplate = `// Code generated by sudo-gen equals. DO NOT EDIT.

package {{.Package}}

{{range .Structs}}
// {{$.MethodName}} returns true if c and other have the same values.
func (c *{{.Name}}) {{$.MethodName}}(other *{{.Name}}) bool {
	if c == other {
		return true
	}
	if c == nil || other == nil {
		return false
	}
{{- range .Fields}}
{{- if .IsPointer}}
{{- if isLocalStruct .}}
	if !c.{{.Name}}.{{$.MethodName}}(other.{{.Name}}) {
		return false
	}
{{- else if eq .TypePkg "time"}}
	if (c.{{.Name}} == nil) != (other.{{.Name}} == nil) {
		return false
	}
	if c.{{.Name}} != nil && !c.{{.Name}}.Equal(*other.{{.Name}}) {
		return false
	}
{{- else}}
	if (c.{{.Name}} == nil) != (other.{{.Name}} == nil) {
		return false
	}
	if c.{{.Name}} != nil && *c.{{.Name}} != *other.{{.Name}} {
		return false
	}
{{- end}}
{{- else if .IsSlice}}
	if len(c.{{.Name}}) != len(other.{{.Name}}) {
		return false
	}
	for i := range c.{{.Name}} {
{{- if and .StructTypeName (eq .TypePkg "")}}
		if !c.{{.Name}}[i].{{$.MethodName}}(&other.{{.Name}}[i]) {
			return false
		}
{{- else}}
		if c.{{.Name}}[i] != other.{{.Name}}[i] {
			return false
		}
{{- end}}
	}
{{- else if .IsMap}}
	if len(c.{{.Name}}) != len(other.{{.Name}}) {
		return false
	}
	for k, v := range c.{{.Name}} {
		ov, ok := other.{{.Name}}[k]
		if !ok {
			return false
		}
{{- if eq .TypeName "map[string]any"}}
		if !equalAny(v, ov) {
			return false
		}
{{- else}}
		if v != ov {
			return false
		}
{{- end}}
	}
{{- else if isLocalStruct .}}
	if !c.{{.Name}}.{{$.MethodName}}(other.{{.Name}}) {
		return false
	}
{{- else if eq .TypePkg "time"}}
	if !c.{{.Name}}.Equal(other.{{.Name}}) {
		return false
	}
{{- else}}
	if c.{{.Name}} != other.{{.Name}} {
		return false
	}
{{- end}}
{{- end}}
	return true
}
{{end}}
{{- $needsEqualAny := false}}
{{- range .Structs}}
{{- range .Fields}}
{{- if eq .TypeName "map[string]any"}}
{{- $needsEqualAny = true}}
{{- end}}
{{- end}}
{{- end}}
{{- if $needsEqualAny}}

func equalAny(a, b any) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	switch av := a.(type) {
	case map[string]any:
		bv, ok := b.(map[string]any)
		if !ok || len(av) != len(bv) {
			return false
		}
		for k, v := range av {
			if ov, ok := bv[k]; !ok || !equalAny(v, ov) {
				return false
			}
		}
		return true
	case []any:
		bv, ok := b.([]any)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if !equalAny(av[i], bv[i]) {
				return false
			}
		}
		return true
	case []string:
		bv, ok := b.([]string)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if av[i] != bv[i] {
				return false
			}
		}
		return true
	case []int:
		bv, ok := b.([]int)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if av[i] != bv[i] {
				return false
			}
		}
		return true
	case string:
		bv, ok := b.(string)
		return ok && av == bv
	case int:
		bv, ok := b.(int)
		return ok && av == bv
	case int64:
		bv, ok := b.(int64)
		return ok && av == bv
	case float64:
		bv, ok := b.(float64)
		return ok && av == bv
	case bool:
		bv, ok := b.(bool)
		return ok && av == bv
	default:
		return a == b
	}
}
{{- end}}
`
