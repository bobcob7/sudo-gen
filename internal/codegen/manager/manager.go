package manager

import (
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/bobcob7/merge-config/internal/codegen"
)

// Subtool implements the manager code generator.
type Subtool struct{}

// Name returns the subtool name.
func (s *Subtool) Name() string { return "manager" }

// Description returns the subtool description.
func (s *Subtool) Description() string {
	return "Generate thread-safe manager with transactions and path-based subscriptions"
}

// Run executes the manager code generation.
func (s *Subtool) Run(cfg codegen.GeneratorConfig) error {
	info, err := codegen.ParseStruct(cfg.SourceDir, cfg.SourceFile, cfg.TypeName)
	if err != nil {
		return fmt.Errorf("parsing struct: %w", err)
	}
	nested, err := codegen.FindNestedStructs(cfg.SourceDir, cfg.SourceFile, info)
	if err != nil {
		return fmt.Errorf("finding nested structs: %w", err)
	}
	paths := BuildPaths(info, nested)
	allStructs := append([]*codegen.StructInfo{info}, nested...)
	return generateManagerFile(cfg, info, allStructs, paths)
}

func generateManagerFile(cfg codegen.GeneratorConfig, info *codegen.StructInfo, structs []*codegen.StructInfo, paths []PathInfo) error {
	baseName := strings.TrimSuffix(cfg.SourceFile, ".go")
	outputFile := filepath.Join(cfg.OutputDir, baseName+"_manager.go")
	needsTime := false
	for _, p := range paths {
		if p.NeedsTimeImport {
			needsTime = true
			break
		}
	}
	data := templateData{
		Package:         cfg.OutputPkg,
		TypeName:        info.Name,
		Paths:           paths,
		Structs:         structs,
		NeedsTimeImport: needsTime,
	}
	gen := codegen.NewTemplateGenerator(templateFuncs())
	return gen.GenerateFile(outputFile, managerTemplate, data)
}

type templateData struct {
	Package         string
	TypeName        string
	Paths           []PathInfo
	Structs         []*codegen.StructInfo
	NeedsTimeImport bool
}

func templateFuncs() template.FuncMap {
	return template.FuncMap{
		"lower":       strings.ToLower,
		"partialType": func(name string) string { return name + "Partial" },
	}
}

const managerTemplate = `// Code generated by sudo-gen manager. DO NOT EDIT.

package {{.Package}}

import (
	"reflect"
	"sync"
{{- if .NeedsTimeImport}}
	"time"
{{- end}}
)

// {{.TypeName}}Manager provides thread-safe access to {{.TypeName}} with change subscriptions.
type {{.TypeName}}Manager struct {
	mu          sync.RWMutex
	config      *{{.TypeName}}
	subscribers map[string][]any
}

// New{{.TypeName}}Manager creates a new manager wrapping the given config.
// If cfg is nil, an empty config is used.
func New{{.TypeName}}Manager(cfg *{{.TypeName}}) *{{.TypeName}}Manager {
	if cfg == nil {
		cfg = &{{.TypeName}}{}
	}
	return &{{.TypeName}}Manager{
		config:      cfg.Copy(),
		subscribers: make(map[string][]any),
	}
}

// Get returns a deep copy of the current configuration.
func (m *{{.TypeName}}Manager) Get() *{{.TypeName}} {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.config.Copy()
}

// Transaction returns a new transaction for making changes.
func (m *{{.TypeName}}Manager) Transaction() *{{.TypeName}}Transaction {
	return &{{.TypeName}}Transaction{
		manager: m,
		partial: &{{.TypeName}}Partial{},
	}
}

// Path constants for subscriptions.
const (
{{- range .Paths}}
	{{$.TypeName}}Path{{.PathConst}} = "{{.Path}}"
{{- end}}
)

{{range .Paths}}
// Subscribe{{.PathConst}} subscribes to changes on {{.Path}}.
// The callback is invoked immediately if the value is set, and on future changes.
// Returns an unsubscribe function.
func (m *{{$.TypeName}}Manager) Subscribe{{.PathConst}}(callback func({{.FieldType}})) func() {
	return m.subscribe({{$.TypeName}}Path{{.PathConst}}, callback)
}
{{end}}

// Subscribe registers a callback for the given path.
// The callback type must match the field type at the path.
// Returns an unsubscribe function.
func (m *{{.TypeName}}Manager) Subscribe(path string, callback any) func() {
	return m.subscribe(path, callback)
}

func (m *{{.TypeName}}Manager) subscribe(path string, callback any) func() {
	m.mu.Lock()
	m.subscribers[path] = append(m.subscribers[path], callback)
	currentValue := m.getValueAtPath(path)
	m.mu.Unlock()
	if !isZeroValue(currentValue) {
		invokeCallback(callback, currentValue)
	}
	return func() {
		m.mu.Lock()
		defer m.mu.Unlock()
		subs := m.subscribers[path]
		for i, sub := range subs {
			if reflect.ValueOf(sub).Pointer() == reflect.ValueOf(callback).Pointer() {
				m.subscribers[path] = append(subs[:i], subs[i+1:]...)
				break
			}
		}
	}
}

func (m *{{.TypeName}}Manager) getValueAtPath(path string) any {
	switch path {
{{- range .Paths}}
	case {{$.TypeName}}Path{{.PathConst}}:
{{- if .ParentIsPtr}}
		if {{.NilCheckPath}} == nil {
			return {{.ZeroValue}}
		}
{{- end}}
		return {{.AccessorExpr}}
{{- end}}
	}
	return nil
}

func (m *{{.TypeName}}Manager) notifySubscribers(path string, value any) {
	for _, callback := range m.subscribers[path] {
		invokeCallback(callback, value)
	}
}

func invokeCallback(callback any, value any) {
	reflect.ValueOf(callback).Call([]reflect.Value{reflect.ValueOf(value)})
}

func isZeroValue(v any) bool {
	if v == nil {
		return true
	}
	rv := reflect.ValueOf(v)
	switch rv.Kind() {
	case reflect.Ptr, reflect.Slice, reflect.Map, reflect.Interface:
		return rv.IsNil()
	}
	return reflect.DeepEqual(v, reflect.Zero(reflect.TypeOf(v)).Interface())
}

// {{.TypeName}}Transaction holds pending changes to be applied.
type {{.TypeName}}Transaction struct {
	manager *{{.TypeName}}Manager
	partial *{{.TypeName}}Partial
}

{{range .Paths}}
{{- if not .SkipTransactionSet}}
// Set{{.PathConst}} sets {{.Path}} in this transaction.
func (t *{{$.TypeName}}Transaction) Set{{.PathConst}}(v {{.FieldType}}) *{{$.TypeName}}Transaction {
{{- $segments := .Segments}}
{{- $depth := len $segments}}
{{- if eq $depth 1}}
{{- if or .IsPointer .IsSlice .IsMap}}
	t.partial.{{.FieldName}} = v
{{- else}}
	t.partial.{{.FieldName}} = &v
{{- end}}
{{- else if eq $depth 2}}
	if t.partial.{{index $segments 0}} == nil {
		t.partial.{{index $segments 0}} = &{{.ParentTypeName}}Partial{}
	}
{{- if or .IsPointer .IsSlice .IsMap}}
	t.partial.{{index $segments 0}}.{{.FieldName}} = v
{{- else}}
	t.partial.{{index $segments 0}}.{{.FieldName}} = &v
{{- end}}
{{- else if eq $depth 3}}
	if t.partial.{{index $segments 0}} == nil {
		t.partial.{{index $segments 0}} = &{{index $segments 0}}Partial{}
	}
	if t.partial.{{index $segments 0}}.{{index $segments 1}} == nil {
		t.partial.{{index $segments 0}}.{{index $segments 1}} = &{{.ParentTypeName}}Partial{}
	}
{{- if or .IsPointer .IsSlice .IsMap}}
	t.partial.{{index $segments 0}}.{{index $segments 1}}.{{.FieldName}} = v
{{- else}}
	t.partial.{{index $segments 0}}.{{index $segments 1}}.{{.FieldName}} = &v
{{- end}}
{{- end}}
	return t
}
{{end}}
{{- end}}

// Commit applies all changes and notifies subscribers.
// Returns the paths that were changed.
func (t *{{.TypeName}}Transaction) Commit() []string {
	t.manager.mu.Lock()
	defer t.manager.mu.Unlock()
	oldValues := make(map[string]any, len(t.manager.subscribers))
	for path := range t.manager.subscribers {
		oldValues[path] = t.manager.getValueAtPath(path)
	}
	t.manager.config.ApplyPartial(t.partial)
	var changed []string
	for path, oldVal := range oldValues {
		newVal := t.manager.getValueAtPath(path)
		if !reflect.DeepEqual(oldVal, newVal) {
			changed = append(changed, path)
			t.manager.notifySubscribers(path, newVal)
		}
	}
	return changed
}
`
