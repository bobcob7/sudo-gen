package manager

import (
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/bobcob7/merge-config/internal/codegen"
)

// Subtool implements the manager code generator.
type Subtool struct{}

// Name returns the subtool name.
func (s *Subtool) Name() string { return "manager" }

// Description returns the subtool description.
func (s *Subtool) Description() string {
	return "Generate thread-safe manager with transactions and subscriptions (no reflection)"
}

// Run executes the manager code generation.
func (s *Subtool) Run(cfg codegen.GeneratorConfig) error {
	info, err := codegen.ParseStruct(cfg.SourceDir, cfg.SourceFile, cfg.TypeName)
	if err != nil {
		return fmt.Errorf("parsing struct: %w", err)
	}
	// Only use top-level fields (no nested paths)
	return generateManagerFile(cfg, info)
}

func generateManagerFile(cfg codegen.GeneratorConfig, info *codegen.StructInfo) error {
	baseName := strings.TrimSuffix(cfg.SourceFile, ".go")
	outputFile := filepath.Join(cfg.OutputDir, baseName+"_manager.go")
	needsTime := false
	needsEqualAny := false
	for _, f := range info.Fields {
		if f.TypePkg == "time" {
			needsTime = true
		}
		if f.TypeName == "map[string]any" {
			needsEqualAny = true
		}
	}
	data := templateData{
		Package:         cfg.OutputPkg,
		TypeName:        info.Name,
		Fields:          info.Fields,
		NeedsTimeImport: needsTime,
		NeedsEqualAny:   needsEqualAny,
	}
	gen := codegen.NewTemplateGenerator(templateFuncs())
	return gen.GenerateFile(outputFile, managerTemplate, data)
}

type templateData struct {
	Package         string
	TypeName        string
	Fields          []codegen.FieldInfo
	NeedsTimeImport bool
	NeedsEqualAny   bool
}

func templateFuncs() template.FuncMap {
	return template.FuncMap{
		"lower":         strings.ToLower,
		"partialType":   func(name string) string { return name + "Partial" },
		"isLocalStruct": isLocalStruct,
		"zeroCheck":     zeroCheck,
		"equalCheck":    equalCheck,
	}
}

func isLocalStruct(f codegen.FieldInfo) bool {
	return f.IsStruct && f.TypePkg == "" && !f.IsSlice && !f.IsMap
}

func zeroCheck(f codegen.FieldInfo) string {
	if f.IsPointer || f.IsSlice || f.IsMap {
		return "v != nil"
	}
	if f.TypePkg == "time" && f.TypeName == "Time" {
		return "!v.IsZero()"
	}
	switch f.TypeName {
	case "string":
		return `v != ""`
	case "bool":
		return "v"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64", "byte", "rune":
		return "v != 0"
	default:
		// For local structs, use a generated zero value comparison
		if f.IsStruct && f.TypePkg == "" {
			return "true" // Always notify for struct types
		}
		return "true"
	}
}

func equalCheck(f codegen.FieldInfo) string {
	if f.IsPointer {
		if isLocalStruct(f) {
			return "old.Equal(new)"
		}
		if f.TypePkg == "time" {
			return "(old == nil && new == nil) || (old != nil && new != nil && old.Equal(*new))"
		}
		return "(old == nil && new == nil) || (old != nil && new != nil && *old == *new)"
	}
	if f.IsSlice {
		return "{{$.TypeName}}Equal{{.Name}}Slice(old, new)"
	}
	if f.IsMap {
		return "{{$.TypeName}}Equal{{.Name}}Map(old, new)"
	}
	if f.TypePkg == "time" && f.TypeName == "Time" {
		return "old.Equal(new)"
	}
	if isLocalStruct(f) {
		return "old.Equal(&new)"
	}
	return "old == new"
}

const managerTemplate = `// Code generated by sudo-gen manager. DO NOT EDIT.

package {{.Package}}

import (
	"sync"
{{- if .NeedsTimeImport}}
	"time"
{{- end}}
)

// {{.TypeName}}Manager provides thread-safe access to {{.TypeName}} with change subscriptions.
type {{.TypeName}}Manager struct {
	mu        sync.RWMutex
	config    *{{.TypeName}}
	nextSubID int
{{- range .Fields}}
	subs{{.Name}} map[int]func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})
{{- end}}
}

// New{{.TypeName}}Manager creates a new manager wrapping the given config.
// If cfg is nil, an empty config is used.
func New{{.TypeName}}Manager(cfg *{{.TypeName}}) *{{.TypeName}}Manager {
	if cfg == nil {
		cfg = &{{.TypeName}}{}
	}
	return &{{.TypeName}}Manager{
		config: cfg.Copy(),
{{- range .Fields}}
		subs{{.Name}}: make(map[int]func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})),
{{- end}}
	}
}

// Get returns a deep copy of the current configuration.
func (m *{{.TypeName}}Manager) Get() *{{.TypeName}} {
	m.mu.RLock()
	defer m.mu.RUnlock()
	return m.config.Copy()
}

// Transaction returns a new transaction for making changes.
func (m *{{.TypeName}}Manager) Transaction() *{{.TypeName}}Transaction {
	return &{{.TypeName}}Transaction{
		manager: m,
		partial: &{{.TypeName}}Partial{},
	}
}

{{range .Fields}}
// Subscribe{{.Name}} subscribes to changes on {{.Name}}.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (m *{{$.TypeName}}Manager) Subscribe{{.Name}}(callback func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})) func() {
	m.mu.Lock()
	id := m.nextSubID
	m.nextSubID++
	m.subs{{.Name}}[id] = callback
	v := m.config.{{.Name}}
	m.mu.Unlock()
{{- if .IsPointer}}
	if v != nil {
		callback(v)
	}
{{- else if .IsSlice}}
	if v != nil {
		callback(v)
	}
{{- else if .IsMap}}
	if v != nil {
		callback(v)
	}
{{- else if and (eq .TypePkg "time") (eq .TypeName "Time")}}
	if !v.IsZero() {
		callback(v)
	}
{{- else if eq .TypeName "string"}}
	if v != "" {
		callback(v)
	}
{{- else if eq .TypeName "bool"}}
	if v {
		callback(v)
	}
{{- else if or (eq .TypeName "int") (eq .TypeName "int8") (eq .TypeName "int16") (eq .TypeName "int32") (eq .TypeName "int64") (eq .TypeName "uint") (eq .TypeName "uint8") (eq .TypeName "uint16") (eq .TypeName "uint32") (eq .TypeName "uint64") (eq .TypeName "float32") (eq .TypeName "float64") (eq .TypeName "byte") (eq .TypeName "rune")}}
	if v != 0 {
		callback(v)
	}
{{- else}}
	callback(v)
{{- end}}
	return func() {
		m.mu.Lock()
		defer m.mu.Unlock()
		delete(m.subs{{.Name}}, id)
	}
}
{{end}}

// {{.TypeName}}Transaction holds pending changes to be applied.
type {{.TypeName}}Transaction struct {
	manager *{{.TypeName}}Manager
	partial *{{.TypeName}}Partial
}

{{range .Fields}}
{{- if not (and .IsPointer (isLocalStruct .))}}
// Set{{.Name}} sets {{.Name}} in this transaction.
func (t *{{$.TypeName}}Transaction) Set{{.Name}}(v {{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}}) *{{$.TypeName}}Transaction {
{{- if or .IsPointer .IsSlice .IsMap}}
	t.partial.{{.Name}} = v
{{- else}}
	t.partial.{{.Name}} = &v
{{- end}}
	return t
}
{{end}}
{{- end}}

// Commit applies all changes and notifies subscribers.
// Returns the fields that were changed.
func (t *{{.TypeName}}Transaction) Commit() []string {
	t.manager.mu.Lock()
	defer t.manager.mu.Unlock()

	var changed []string
{{range .Fields}}
{{- if not (and .IsPointer (isLocalStruct .))}}
	// Check {{.Name}}
	if {{if or .IsPointer .IsSlice .IsMap}}t.partial.{{.Name}} != nil{{else}}t.partial.{{.Name}} != nil{{end}} {
		old{{.Name}} := t.manager.config.{{.Name}}
		t.manager.config.{{.Name}} = {{if or .IsPointer .IsSlice .IsMap}}t.partial.{{.Name}}{{else}}*t.partial.{{.Name}}{{end}}
		new{{.Name}} := t.manager.config.{{.Name}}
		if !{{$.TypeName}}equal{{.Name}}(old{{.Name}}, new{{.Name}}) {
			changed = append(changed, "{{.Name}}")
			for _, cb := range t.manager.subs{{.Name}} {
				cb(new{{.Name}})
			}
		}
	}
{{- end}}
{{end}}
	return changed
}
{{range .Fields}}
{{- if and .IsPointer (not (isLocalStruct .))}}
func {{$.TypeName}}equal{{.Name}}(old, new {{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}}) bool {
	if old == nil && new == nil {
		return true
	}
	if old == nil || new == nil {
		return false
	}
{{- if and (eq .TypePkg "time") (eq .TypeName "Time")}}
	return old.Equal(*new)
{{- else}}
	return *old == *new
{{- end}}
}
{{- else if .IsSlice}}
func {{$.TypeName}}equal{{.Name}}(old, new {{.TypeName}}) bool {
	if len(old) != len(new) {
		return false
	}
	for i := range old {
{{- if and .StructTypeName (eq .TypePkg "")}}
		if !old[i].Equal(&new[i]) {
			return false
		}
{{- else}}
		if old[i] != new[i] {
			return false
		}
{{- end}}
	}
	return true
}
{{- else if .IsMap}}
func {{$.TypeName}}equal{{.Name}}(old, new {{.TypeName}}) bool {
	if len(old) != len(new) {
		return false
	}
	for k, v := range old {
		ov, ok := new[k]
		if !ok {
			return false
		}
{{- if eq .TypeName "map[string]any"}}
		if !{{$.TypeName}}EqualAny(v, ov) {
			return false
		}
{{- else}}
		if v != ov {
			return false
		}
{{- end}}
	}
	return true
}
{{- else if and (eq .TypePkg "time") (eq .TypeName "Time")}}
func {{$.TypeName}}equal{{.Name}}(old, new {{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}}) bool {
	return old.Equal(new)
}
{{- else if isLocalStruct .}}
func {{$.TypeName}}equal{{.Name}}(old, new {{.TypeName}}) bool {
	return old.Equal(&new)
}
{{- else}}
func {{$.TypeName}}equal{{.Name}}(old, new {{.TypeName}}) bool {
	return old == new
}
{{- end}}
{{end}}
{{- if .NeedsEqualAny}}

func {{.TypeName}}EqualAny(a, b any) bool {
	if a == nil && b == nil {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	switch av := a.(type) {
	case map[string]any:
		bv, ok := b.(map[string]any)
		if !ok || len(av) != len(bv) {
			return false
		}
		for k, v := range av {
			if ov, ok := bv[k]; !ok || !{{.TypeName}}EqualAny(v, ov) {
				return false
			}
		}
		return true
	case []any:
		bv, ok := b.([]any)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if !{{.TypeName}}EqualAny(av[i], bv[i]) {
				return false
			}
		}
		return true
	case []string:
		bv, ok := b.([]string)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if av[i] != bv[i] {
				return false
			}
		}
		return true
	case []int:
		bv, ok := b.([]int)
		if !ok || len(av) != len(bv) {
			return false
		}
		for i := range av {
			if av[i] != bv[i] {
				return false
			}
		}
		return true
	case string:
		bv, ok := b.(string)
		return ok && av == bv
	case int:
		bv, ok := b.(int)
		return ok && av == bv
	case int64:
		bv, ok := b.(int64)
		return ok && av == bv
	case float64:
		bv, ok := b.(float64)
		return ok && av == bv
	case bool:
		bv, ok := b.(bool)
		return ok && av == bv
	default:
		return a == b
	}
}
{{- end}}
`
