package layerbroker

const layerBrokerTemplate = `// Code generated by sudo-gen layerbroker. DO NOT EDIT.

// {{brokerType .TypeName}} Overview
//
// {{brokerType .TypeName}} provides thread-safe access to {{.TypeName}} with two key features:
//
//   - Ordered Layers: Multiple layers can apply partial updates, allowing configuration
//     to be built up from multiple sources (defaults, files, environment, flags, etc.)
//   - Field Subscriptions: Subscribe to individual field changes with type-safe callbacks
//     that fire immediately with the current value (if set) and on subsequent changes.
//
// # Creating a LayerBroker
//
// Create a new broker with an initial configuration (or nil for empty):
//
//	broker := {{newBroker .TypeName}}(&{{.TypeName}}{Name: "default"})
//	// or
//	broker := {{newBroker .TypeName}}(nil)
//
// # Reading Configuration
//
// Get a deep copy of the current configuration:
//
//	cfg := broker.Get()
//	fmt.Println(cfg.Name)
//
// # Applying Updates with Layers
//
// Create layers to apply partial updates. Each layer can apply multiple updates
// over time, and updates are applied in the order received:
//
//	// Create a layer (e.g., for file-based config)
//	fileLayer := broker.Layer()
//	fileLayer.Set(&{{.TypeName}}Partial{Name: ptr("from-file")})
//
//	// Create another layer (e.g., for environment variables)
//	envLayer := broker.Layer()
//	envLayer.Set(&{{.TypeName}}Partial{Name: ptr("from-env")})
//
//	// Later updates from any layer are applied immediately
//	fileLayer.Set(&{{.TypeName}}Partial{Name: ptr("updated-from-file")})
//
// # Subscribing to Field Changes
//
// Subscribe to individual fields with type-safe callbacks. The callback is invoked:
//   - Immediately with the current value (if non-zero)
//   - Whenever the field value changes
//
// The subscribe method returns an unsubscribe function:
//
//	unsub := broker.SubscribeName(func(name string) {
//	    fmt.Println("Name changed to:", name)
//	})
//	defer unsub() // Clean up when done
//
// Subscribers are only notified when the value actually changes. Setting the same
// value again does not trigger a notification.
//
// # Thread Safety
//
// All operations on {{brokerType .TypeName}} are thread-safe. Multiple goroutines can
// safely call Get(), Layer().Set(), and Subscribe methods concurrently.
//
// Get() is lock-free using atomic pointer load, making reads very fast.
// Set() uses copy-on-write with atomic swap, ensuring readers never block.
//
// # Dependencies
//
// This generated code requires the following to also be generated:
//   - {{.TypeName}}Partial (from: sudo-gen merge)
//   - {{.TypeName}}.Copy() (from: sudo-gen copy)
package {{.Package}}

import (
{{- if .GenerateJSON}}
	"encoding/json"
{{- end}}
{{- if .NeedsReflectImport}}
	"reflect"
{{- end}}
	"sync"
	"sync/atomic"
{{- if .NeedsTimeImport}}
	"time"
{{- end}}
)

// {{brokerType .TypeName}} provides thread-safe access to {{.TypeName}} with ordered layer updates and subscriptions.
type {{brokerType .TypeName}} struct {
	base      *{{.TypeName}}
	config    atomic.Pointer[{{.TypeName}}]
	mu        sync.Mutex // protects subscribers, layers, and serializes writes
	nextSubID int
	layers    []*{{layerType .TypeName}}
{{- range .Fields}}
	subs{{.Name}} map[int]func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})
{{- end}}
}

// {{newBroker .TypeName}} creates a new LayerBroker wrapping the given config.
// If cfg is nil, an empty config is used.
func {{newBroker .TypeName}}(cfg *{{.TypeName}}) *{{brokerType .TypeName}} {
	if cfg == nil {
		cfg = &{{.TypeName}}{}
	}
	b := &{{brokerType .TypeName}}{
		base: cfg.Copy(),
{{- range .Fields}}
		subs{{.Name}}: make(map[int]func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})),
{{- end}}
	}
	b.config.Store(cfg.Copy())
	return b
}

// Get returns a deep copy of the current configuration.
// This is a lock-free operation using atomic pointer load.
func (b *{{brokerType .TypeName}}) Get() *{{.TypeName}} {
	return b.config.Load().Copy()
}

// Layer returns a new layer for applying partial changes.
func (b *{{brokerType .TypeName}}) Layer() *{{layerType .TypeName}} {
	b.mu.Lock()
	defer b.mu.Unlock()
	l := &{{layerType .TypeName}}{broker: b}
	b.layers = append(b.layers, l)
	return l
}

{{range .Fields}}
// Subscribe{{.Name}} subscribes to changes on {{.Name}}.
// The callback is invoked immediately if the value is non-zero, and on future changes.
// Returns an unsubscribe function.
func (b *{{brokerType $.TypeName}}) Subscribe{{.Name}}(callback func({{if .IsPointer}}*{{end}}{{if .TypePkg}}{{.TypePkg}}.{{end}}{{.TypeName}})) func() {
	b.mu.Lock()
	id := b.nextSubID
	b.nextSubID++
	b.subs{{.Name}}[id] = callback
	v := b.config.Load().{{.Name}}
	b.mu.Unlock()
	{{- if .IsPointer}}
	if v != nil {
		callback(v)
	}
	{{- else if .IsSlice}}
	if v != nil {
		callback(v)
	}
	{{- else if .IsMap}}
	if v != nil {
		callback(v)
	}
	{{- else if and (eq .TypePkg "time") (eq .TypeName "Time")}}
	if !v.IsZero() {
		callback(v)
	}
	{{- else if eq .TypeName "string"}}
	if v != "" {
		callback(v)
	}
	{{- else if eq .TypeName "bool"}}
	if v {
		callback(v)
	}
	{{- else if or (eq .TypeName "int") (eq .TypeName "int8") (eq .TypeName "int16") (eq .TypeName "int32") (eq .TypeName "int64") (eq .TypeName "uint") (eq .TypeName "uint8") (eq .TypeName "uint16") (eq .TypeName "uint32") (eq .TypeName "uint64") (eq .TypeName "float32") (eq .TypeName "float64") (eq .TypeName "byte") (eq .TypeName "rune")}}
	if v != 0 {
		callback(v)
	}
	{{- else}}
	callback(v)
	{{- end}}
	return func() {
		b.mu.Lock()
		defer b.mu.Unlock()
		delete(b.subs{{.Name}}, id)
	}
}
{{end}}

// {{layerType .TypeName}} applies partial updates to the LayerBroker.
type {{layerType .TypeName}} struct {
	broker  *{{brokerType .TypeName}}
	partial *{{.TypeName}}Partial
}

// Set applies the partial and notifies subscribers for changed fields.
// Uses copy-on-write: copies the config, applies changes, then atomically swaps.
func (l *{{layerType .TypeName}}) Set(p *{{.TypeName}}Partial) {
	if p == nil {
		return
	}
	l.broker.mu.Lock()
	defer l.broker.mu.Unlock()
	if l.partial == nil {
		l.partial = &{{.TypeName}}Partial{}
	}
	l.mergePartial(p)
	newCfg := l.broker.recompute()
	oldCfg := l.broker.config.Load()
{{- range .Fields}}
{{- if not (and .IsPointer (isLocalStruct .))}}
	if old, new := oldCfg.{{.Name}}, newCfg.{{.Name}}; {{if .IsSlice}}!reflect.DeepEqual(old, new){{else if .IsMap}}!reflect.DeepEqual(old, new){{else if and .IsPointer (not (isLocalStruct .))}}(old == nil) != (new == nil) || (old != nil && *old != *new){{else if and (eq .TypePkg "time") (eq .TypeName "Time")}}!old.Equal(new){{else if isLocalStruct .}}!old.Equal(&new){{else}}old != new{{end}} {
		for _, cb := range l.broker.subs{{.Name}} {
			cb(new)
		}
	}
{{- end}}
{{- end}}
	l.broker.config.Store(newCfg)
}

// mergePartial merges the given partial into the layer's accumulated partial.
func (l *{{layerType .TypeName}}) mergePartial(p *{{.TypeName}}Partial) {
{{- range .Fields}}
	if p.{{.Name}} != nil {
		l.partial.{{.Name}} = p.{{.Name}}
	}
{{- end}}
}

// recompute rebuilds the config from base and all layer partials.
func (b *{{brokerType .TypeName}}) recompute() *{{.TypeName}} {
	cfg := b.base.Copy()
	for _, layer := range b.layers {
		if layer.partial != nil {
			cfg.ApplyPartial(layer.partial)
		}
	}
	return cfg
}
{{if .GenerateJSON}}
// {{brokerType .TypeName}}State represents the serializable state of the broker.
type {{brokerType .TypeName}}State struct {
	Base   *{{.TypeName}}          ` + "`" + `json:"base"` + "`" + `
	Layers []*{{.TypeName}}Partial ` + "`" + `json:"layers"` + "`" + `
	Final  *{{.TypeName}}          ` + "`" + `json:"final"` + "`" + `
}

// MarshalJSON serializes the broker state including base config, all layer partials, and final merged config.
func (b *{{brokerType .TypeName}}) MarshalJSON() ([]byte, error) {
	b.mu.Lock()
	defer b.mu.Unlock()
	layers := make([]*{{.TypeName}}Partial, 0, len(b.layers))
	for _, layer := range b.layers {
		layers = append(layers, layer.partial)
	}
	state := {{brokerType .TypeName}}State{
		Base:   b.base,
		Layers: layers,
		Final:  b.config.Load(),
	}
	return json.Marshal(state)
}
{{end}}
`

const layerBrokerTestTemplate = `// Code generated by sudo-gen layerbroker. DO NOT EDIT.

package {{.Package}}

import (
{{- if .GenerateJSON}}
	"encoding/json"
{{- end}}
	"testing"
{{- if .NeedsTime}}
	"time"
{{- end}}
)

func {{lower .TypeName}}Ptr[T any](v T) *T {
	return &v
}
{{if and .StringField .IntField}}
func Test{{brokerType .TypeName}}SubscriptionOrder(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.StringField}}: "initial", {{.IntField}}: 8080})
	layer1 := broker.Layer()
	var stringUpdates []string
	var intUpdates []int
	unsubString := broker.Subscribe{{.StringField}}(func(v string) {
		stringUpdates = append(stringUpdates, v)
	})
	defer unsubString()
	if len(stringUpdates) != 1 || stringUpdates[0] != "initial" {
		t.Fatalf("expected initial {{.StringField}} callback, got %v", stringUpdates)
	}
	unsubInt := broker.Subscribe{{.IntField}}(func(v int) {
		intUpdates = append(intUpdates, v)
	})
	defer unsubInt()
	if len(intUpdates) != 1 || intUpdates[0] != 8080 {
		t.Fatalf("expected initial {{.IntField}} callback, got %v", intUpdates)
	}
	layer1.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("updated")})
	if len(stringUpdates) != 2 || stringUpdates[1] != "updated" {
		t.Fatalf("expected {{.StringField}} update, got %v", stringUpdates)
	}
	if len(intUpdates) != 1 {
		t.Fatalf("{{.IntField}} subscriber should not have been called, got %v", intUpdates)
	}
	layer2 := broker.Layer()
	layer2.Set(&{{.TypeName}}Partial{ {{.IntField}}: {{lower .TypeName}}Ptr(9090)})
	if len(intUpdates) != 2 || intUpdates[1] != 9090 {
		t.Fatalf("expected {{.IntField}} update, got %v", intUpdates)
	}
	if len(stringUpdates) != 2 {
		t.Fatalf("{{.StringField}} subscriber should not have been called, got %v", stringUpdates)
	}
	cfg := broker.Get()
	if cfg.{{.StringField}} != "updated" {
		t.Errorf("expected {{.StringField}}=updated, got %s", cfg.{{.StringField}})
	}
	if cfg.{{.IntField}} != 9090 {
		t.Errorf("expected {{.IntField}}=9090, got %d", cfg.{{.IntField}})
	}
}

func Test{{brokerType .TypeName}}LowerLayerOverridden(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer1 := broker.Layer()
	layer2 := broker.Layer()
	layer1.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("one")})
	layer2.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("two"), {{.IntField}}: {{lower .TypeName}}Ptr(8080)})
	var updates []string
	unsub := broker.Subscribe{{.StringField}}(func(v string) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] != "two" {
		t.Fatalf("expected initial callback with 'two', got %v", updates)
	}
	layer1.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("three")})
	if len(updates) != 1 {
		t.Fatalf("expected no update when lower layer is overridden, got %v", updates)
	}
	cfg := broker.Get()
	if cfg.{{.StringField}} != "two" {
		t.Errorf("expected {{.StringField}}=two, got %s", cfg.{{.StringField}})
	}
}

func Test{{brokerType .TypeName}}MultipleLayersPriority(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer1 := broker.Layer()
	layer2 := broker.Layer()
	layer3 := broker.Layer()
	
	// Set same field in all layers - last layer should win
	layer1.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("layer1")})
	layer2.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("layer2")})
	layer3.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("layer3")})
	
	cfg := broker.Get()
	if cfg.{{.StringField}} != "layer3" {
		t.Errorf("expected {{.StringField}}=layer3 (last layer should win), got %s", cfg.{{.StringField}})
	}
	
	// Update layer2, but layer3 still wins
	layer2.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("layer2-updated")})
	cfg = broker.Get()
	if cfg.{{.StringField}} != "layer3" {
		t.Errorf("expected {{.StringField}}=layer3 (higher layer should still win), got %s", cfg.{{.StringField}})
	}
}

func Test{{brokerType .TypeName}}MultipleSubscribers(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.StringField}}: "initial"})
	var updates1, updates2 []string
	
	unsub1 := broker.Subscribe{{.StringField}}(func(v string) {
		updates1 = append(updates1, v)
	})
	defer unsub1()
	
	unsub2 := broker.Subscribe{{.StringField}}(func(v string) {
		updates2 = append(updates2, v)
	})
	defer unsub2()
	
	if len(updates1) != 1 || len(updates2) != 1 {
		t.Fatalf("expected both subscribers to get initial value")
	}
	
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("updated")})
	
	if len(updates1) != 2 || updates1[1] != "updated" {
		t.Errorf("expected subscriber1 to get update, got %v", updates1)
	}
	if len(updates2) != 2 || updates2[1] != "updated" {
		t.Errorf("expected subscriber2 to get update, got %v", updates2)
	}
}
{{end}}
{{if .StringField}}
func Test{{brokerType .TypeName}}Unsubscribe(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.StringField}}: "test"})
	var updates []string
	unsub := broker.Subscribe{{.StringField}}(func(v string) {
		updates = append(updates, v)
	})
	if len(updates) != 1 {
		t.Fatalf("expected 1 update, got %d", len(updates))
	}
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("changed")})
	if len(updates) != 2 {
		t.Fatalf("expected 2 updates, got %d", len(updates))
	}
	unsub()
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("ignored")})
	if len(updates) != 2 {
		t.Fatalf("expected 2 updates after unsubscribe, got %d", len(updates))
	}
	if broker.Get().{{.StringField}} != "ignored" {
		t.Errorf("expected {{.StringField}}=ignored, got %s", broker.Get().{{.StringField}})
	}
}

func Test{{brokerType .TypeName}}SubscribeToEmptyField(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	var callCount int
	unsub := broker.Subscribe{{.StringField}}(func(v string) {
		callCount++
	})
	defer unsub()
	
	// Should not be called initially since field is empty
	if callCount != 0 {
		t.Errorf("expected 0 calls for empty field, got %d", callCount)
	}
	
	// Should be called when field is set
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("test")})
	if callCount != 1 {
		t.Errorf("expected 1 call after setting field, got %d", callCount)
	}
}
{{end}}
{{if .IntField}}
func Test{{brokerType .TypeName}}NoChangeNoNotify(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.IntField}}: 42})
	var updates []int
	unsub := broker.Subscribe{{.IntField}}(func(v int) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 {
		t.Fatalf("expected 1 update, got %d", len(updates))
	}
	// Setting to same value should NOT trigger callback
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.IntField}}: {{lower .TypeName}}Ptr(42)})
	if len(updates) != 1 {
		t.Fatalf("expected 1 update (no change), got %d", len(updates))
	}
	// Setting to different value should trigger callback
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.IntField}}: {{lower .TypeName}}Ptr(100)})
	if len(updates) != 2 || updates[1] != 100 {
		t.Fatalf("expected 2 updates with 100, got %v", updates)
	}
}

func Test{{brokerType .TypeName}}ZeroValueUpdate(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.IntField}}: 42})
	var updates []int
	unsub := broker.Subscribe{{.IntField}}(func(v int) {
		updates = append(updates, v)
	})
	defer unsub()
	
	// Setting to zero value should trigger callback
	broker.Layer().Set(&{{.TypeName}}Partial{ {{.IntField}}: {{lower .TypeName}}Ptr(0)})
	if len(updates) != 2 || updates[1] != 0 {
		t.Errorf("expected zero value update, got %v", updates)
	}
}
{{end}}

func Test{{brokerType .TypeName}}NilPartial(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{})
	broker.Layer().Set(nil) // should not panic
}

func Test{{brokerType .TypeName}}GetReturnsIndependentCopy(t *testing.T) {
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{})
	cfg1 := broker.Get()
	cfg2 := broker.Get()
	
	if cfg1 == cfg2 {
		t.Error("Get() should return independent copies, not the same pointer")
	}
}

func Test{{brokerType .TypeName}}ConcurrentLayerCreation(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	done := make(chan bool)
	
	// Create layers concurrently
	for i := 0; i < 10; i++ {
		go func() {
			layer := broker.Layer()
			if layer == nil {
				t.Error("Layer() returned nil")
			}
			done <- true
		}()
	}
	
	for i := 0; i < 10; i++ {
		<-done
	}
}

func Test{{brokerType .TypeName}}BaseConfigPreserved(t *testing.T) {
	{{if .StringField}}
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.StringField}}: "base"})
	layer := broker.Layer()
	layer.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("layer")})
	
	cfg := broker.Get()
	if cfg.{{.StringField}} != "layer" {
		t.Errorf("expected {{.StringField}}=layer, got %s", cfg.{{.StringField}})
	}
	
	// Create new broker to verify base is not mutated
	broker2 := {{newBroker .TypeName}}(&{{.TypeName}}{ {{.StringField}}: "base"})
	cfg2 := broker2.Get()
	if cfg2.{{.StringField}} != "base" {
		t.Errorf("base config should be preserved, got %s", cfg2.{{.StringField}})
	}
	{{else}}
	broker := {{newBroker .TypeName}}(&{{.TypeName}}{})
	broker.Layer().Set(&{{.TypeName}}Partial{})
	cfg := broker.Get()
	if cfg == nil {
		t.Error("Get() should not return nil")
	}
	{{end}}
}
{{range .Fields}}{{if and (not .IsSlice) (not .IsMap) (not .IsPointer) (not .IsStruct)}}{{if eq .TypeName "int32"}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: 42})
	var updates []{{.TypeName}}
	unsub := broker.Subscribe{{.Name}}(func(v {{.TypeName}}) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] != 42 {
		t.Fatalf("expected initial callback with 42, got %v", updates)
	}
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: {{lower $.TypeName}}Ptr({{.TypeName}}(100))})
	if len(updates) != 2 || updates[1] != 100 {
		t.Fatalf("expected update callback with 100, got %v", updates)
	}
}
{{end}}{{if eq .TypeName "int64"}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: 42})
	var updates []{{.TypeName}}
	unsub := broker.Subscribe{{.Name}}(func(v {{.TypeName}}) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] != 42 {
		t.Fatalf("expected initial callback with 42, got %v", updates)
	}
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: {{lower $.TypeName}}Ptr({{.TypeName}}(100))})
	if len(updates) != 2 || updates[1] != 100 {
		t.Fatalf("expected update callback with 100, got %v", updates)
	}
}
{{end}}{{if eq .TypeName "float64"}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: 3.14})
	var updates []{{.TypeName}}
	unsub := broker.Subscribe{{.Name}}(func(v {{.TypeName}}) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] != 3.14 {
		t.Fatalf("expected initial callback with 3.14, got %v", updates)
	}
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: {{lower $.TypeName}}Ptr(2.71)})
	if len(updates) != 2 || updates[1] != 2.71 {
		t.Fatalf("expected update callback with 2.71, got %v", updates)
	}
}
{{end}}{{if eq .TypeName "bool"}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: true})
	var updates []bool
	unsub := broker.Subscribe{{.Name}}(func(v bool) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || !updates[0] {
		t.Fatalf("expected initial callback with true, got %v", updates)
	}
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: {{lower $.TypeName}}Ptr(false)})
	if len(updates) != 2 || updates[1] {
		t.Fatalf("expected update callback with false, got %v", updates)
	}
}
{{end}}{{end}}{{end}}
{{range .Fields}}{{if .IsPointer}}{{if not .IsStruct}}{{if eq .TypeName "string"}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}Pointer(t *testing.T) {
	val := "initial"
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: &val})
	var updates []*string
	unsub := broker.Subscribe{{.Name}}(func(v *string) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] == nil || *updates[0] != "initial" {
		t.Fatalf("expected initial callback with 'initial', got %v", updates)
	}
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: {{lower $.TypeName}}Ptr("updated")})
	if len(updates) != 2 || updates[1] == nil || *updates[1] != "updated" {
		t.Fatalf("expected update callback with 'updated', got %v", updates)
	}
}
{{end}}{{end}}{{end}}{{end}}
{{range .Fields}}{{if .IsSlice}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}Slice(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: {{.TypeName}}{}})
	var callCount int
	unsub := broker.Subscribe{{.Name}}(func(v {{.TypeName}}) {
		callCount++
	})
	defer unsub()
	// Empty slice is non-nil, so should get initial callback
	if callCount != 1 {
		t.Fatalf("expected 1 initial callback, got %d", callCount)
	}
	// Set a new slice
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: make({{.TypeName}}, 3)})
	if callCount != 2 {
		t.Fatalf("expected 2 callbacks after update, got %d", callCount)
	}
}
{{end}}{{end}}
{{range .Fields}}{{if .IsMap}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}Map(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: make({{.TypeName}})})
	var callCount int
	unsub := broker.Subscribe{{.Name}}(func(v {{.TypeName}}) {
		callCount++
	})
	defer unsub()
	// Empty map is non-nil, so should get initial callback
	if callCount != 1 {
		t.Fatalf("expected 1 initial callback, got %d", callCount)
	}
}
{{end}}{{end}}
{{range .Fields}}{{if and .IsPointer .IsStruct (eq .TypePkg "")}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}Struct(t *testing.T) {
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: &{{.TypeName}}{}})
	var callCount int
	unsub := broker.Subscribe{{.Name}}(func(v *{{.TypeName}}) {
		callCount++
	})
	defer unsub()
	if callCount != 1 {
		t.Fatalf("expected 1 initial callback, got %d", callCount)
	}
}
{{end}}{{end}}
{{range .Fields}}{{if and (not .IsPointer) (eq .TypePkg "time") (eq .TypeName "Time")}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}Time(t *testing.T) {
	now := time.Now()
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: now})
	var updates []time.Time
	unsub := broker.Subscribe{{.Name}}(func(v time.Time) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || !updates[0].Equal(now) {
		t.Fatalf("expected initial callback with current time, got %v", updates)
	}
	later := now.Add(time.Hour)
	broker.Layer().Set(&{{$.TypeName}}Partial{ {{.Name}}: &later})
	if len(updates) != 2 || !updates[1].Equal(later) {
		t.Fatalf("expected update callback with later time, got %v", updates)
	}
}
{{end}}{{end}}
{{range .Fields}}{{if and .IsPointer (eq .TypePkg "time") (eq .TypeName "Time")}}
func Test{{brokerType $.TypeName}}Subscribe{{.Name}}TimePointer(t *testing.T) {
	now := time.Now()
	broker := {{newBroker $.TypeName}}(&{{$.TypeName}}{ {{.Name}}: &now})
	var updates []*time.Time
	unsub := broker.Subscribe{{.Name}}(func(v *time.Time) {
		updates = append(updates, v)
	})
	defer unsub()
	if len(updates) != 1 || updates[0] == nil || !updates[0].Equal(now) {
		t.Fatalf("expected initial callback with current time, got %v", updates)
	}
}
{{end}}{{end}}
{{if .GenerateJSON}}
func Test{{brokerType .TypeName}}MarshalJSON(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer := broker.Layer()
	{{if .StringField}}layer.Set(&{{.TypeName}}Partial{ {{.StringField}}: {{lower .TypeName}}Ptr("test")}){{end}}
	data, err := json.Marshal(broker)
	if err != nil {
		t.Fatalf("MarshalJSON failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("expected non-empty JSON output")
	}
	// Verify it's valid JSON
	var result map[string]any
	if err := json.Unmarshal(data, &result); err != nil {
		t.Fatalf("result is not valid JSON: %v", err)
	}
	if _, ok := result["base"]; !ok {
		t.Error("expected 'base' field in JSON output")
	}
	if _, ok := result["layers"]; !ok {
		t.Error("expected 'layers' field in JSON output")
	}
	if _, ok := result["final"]; !ok {
		t.Error("expected 'final' field in JSON output")
	}
}

func Test{{brokerType .TypeName}}MarshalJSONEmpty(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	data, err := json.Marshal(broker)
	if err != nil {
		t.Fatalf("MarshalJSON failed: %v", err)
	}
	if len(data) == 0 {
		t.Error("expected non-empty JSON output")
	}
}
{{end}}

func Test{{brokerType .TypeName}}SetAllFieldTypes(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer := broker.Layer()
	// Test setting all field types to exercise mergePartial
	partial := &{{.TypeName}}Partial{}
{{range .Fields}}{{if not .IsSlice}}{{if not .IsMap}}{{if not .IsPointer}}{{if not .IsStruct}}{{if eq .TypeName "string"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr("test")
{{else if eq .TypeName "int"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr(42)
{{else if eq .TypeName "int32"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr(int32(42))
{{else if eq .TypeName "int64"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr(int64(42))
{{else if eq .TypeName "float64"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr(3.14)
{{else if eq .TypeName "bool"}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr(true)
{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
	layer.Set(partial)
	cfg := broker.Get()
	if cfg == nil {
		t.Fatal("Get() returned nil after setting fields")
	}
}

func Test{{brokerType .TypeName}}SetSliceAndMapFields(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer := broker.Layer()
	partial := &{{.TypeName}}Partial{}
{{range .Fields}}{{if .IsSlice}}	partial.{{.Name}} = make({{.TypeName}}, 1)
{{else if .IsMap}}	partial.{{.Name}} = make({{.TypeName}})
{{end}}{{end}}
	layer.Set(partial)
	cfg := broker.Get()
	if cfg == nil {
		t.Fatal("Get() returned nil after setting fields")
	}
}

func Test{{brokerType .TypeName}}SetPointerFields(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer := broker.Layer()
	partial := &{{.TypeName}}Partial{}
{{range .Fields}}{{if and .IsPointer (not .IsStruct) (eq .TypePkg "") (eq .TypeName "string")}}	partial.{{.Name}} = {{lower $.TypeName}}Ptr("test")
{{end}}{{end}}
	layer.Set(partial)
	cfg := broker.Get()
	if cfg == nil {
		t.Fatal("Get() returned nil after setting fields")
	}
}
{{range .Fields}}{{if and .IsPointer .IsStruct (eq .TypePkg "")}}
func Test{{brokerType $.TypeName}}SetNestedStruct{{.Name}}(t *testing.T) {
	broker := {{newBroker $.TypeName}}(nil)
	layer := broker.Layer()
	partial := &{{$.TypeName}}Partial{
		{{.Name}}: &{{.TypeName}}Partial{},
	}
	layer.Set(partial)
	cfg := broker.Get()
	if cfg == nil {
		t.Fatal("Get() returned nil after setting nested struct")
	}
}
{{end}}{{end}}
{{if .NeedsTime}}
func Test{{brokerType .TypeName}}SetTimeFields(t *testing.T) {
	broker := {{newBroker .TypeName}}(nil)
	layer := broker.Layer()
	now := time.Now()
	partial := &{{.TypeName}}Partial{}
{{range .Fields}}{{if and (not .IsPointer) (eq .TypePkg "time") (eq .TypeName "Time")}}	partial.{{.Name}} = &now
{{end}}{{end}}
{{range .Fields}}{{if and .IsPointer (eq .TypePkg "time") (eq .TypeName "Time")}}	partial.{{.Name}} = &now
{{end}}{{end}}
	layer.Set(partial)
	cfg := broker.Get()
	if cfg == nil {
		t.Fatal("Get() returned nil after setting time fields")
	}
}
{{end}}
`
