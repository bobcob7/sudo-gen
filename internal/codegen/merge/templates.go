package merge

const partialTemplate = `// Code generated by sudo-gen merge. DO NOT EDIT.

package {{.Package}}

{{if .Imports}}
import (
{{- range .Imports}}
	{{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
{{- end}}
)
{{end}}

{{range .Structs}}
type {{partialType .Name}} struct {
{{- range .Fields}}
	{{.Name}} {{pointerType .}} {{.Tag}}
{{- end}}
}
{{end}}
`

const mergeTemplate = `// Code generated by sudo-gen merge. DO NOT EDIT.

package {{.Package}}

{{range .Structs}}
func (c *{{.Name}}) ApplyPartial(p *{{partialType .Name}}) {
	if c == nil || p == nil {
		return
	}
{{- range .Fields}}
{{- if .IsSlice}}
	if p.{{.Name}} != nil {
		c.{{.Name}} = make({{.TypeName}}, len(p.{{.Name}}))
		copy(c.{{.Name}}, p.{{.Name}})
	}
{{- else if .IsMap}}
	if p.{{.Name}} != nil {
		if c.{{.Name}} == nil {
			c.{{.Name}} = make({{.TypeName}}, len(p.{{.Name}}))
		}
		for k, v := range p.{{.Name}} {
			c.{{.Name}}[k] = v
		}
	}
{{- else if .IsPointer}}
	{{- if needsConversion .}}
	if p.{{.Name}} != nil {
		if c.{{.Name}} == nil {
			c.{{.Name}} = &{{.TypeName}}{}
		}
		c.{{.Name}}.ApplyPartial(p.{{.Name}})
	}
	{{- else}}
	if p.{{.Name}} != nil {
		v := *p.{{.Name}}
		c.{{.Name}} = &v
	}
	{{- end}}
{{- else if needsConversion .}}
	if p.{{.Name}} != nil {
		c.{{.Name}}.ApplyPartial(p.{{.Name}})
	}
{{- else}}
	if p.{{.Name}} != nil {
		c.{{.Name}} = *p.{{.Name}}
	}
{{- end}}
{{- end}}
}
{{end}}
`

const mergeTestTemplate = `// Code generated by sudo-gen merge. DO NOT EDIT.

package {{.Package}}

import (
	"testing"
)

func mergePtr[T any](v T) *T {
	return &v
}
{{range .Structs}}
func Test{{.Name}}ApplyPartialNil(t *testing.T) {
	var c *{{.Name}}
	c.ApplyPartial(nil) // should not panic

	c = &{{.Name}}{}
	c.ApplyPartial(nil) // should not panic
}

func Test{{.Name}}ApplyPartialEmpty(t *testing.T) {
	c := &{{.Name}}{}
	p := &{{partialType .Name}}{}
	c.ApplyPartial(p) // should not panic or change anything
}
{{$typeName := .Name}}{{range .Fields}}{{if not .IsSlice}}{{if not .IsMap}}{{if not .IsStruct}}{{if not .IsPointer}}{{if eq .TypeName "string"}}
func Test{{$typeName}}ApplyPartial_{{.Name}}(t *testing.T) {
	c := &{{$typeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr("test") }
	c.ApplyPartial(p)
	if c.{{.Name}} != "test" {
		t.Errorf("expected {{.Name}}=test, got %s", c.{{.Name}})
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}Overwrite(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: "original" }
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr("updated") }
	c.ApplyPartial(p)
	if c.{{.Name}} != "updated" {
		t.Errorf("expected {{.Name}}=updated, got %s", c.{{.Name}})
	}
}
{{end}}{{if eq .TypeName "int"}}
func Test{{$typeName}}ApplyPartial_{{.Name}}(t *testing.T) {
	c := &{{$typeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr(42) }
	c.ApplyPartial(p)
	if c.{{.Name}} != 42 {
		t.Errorf("expected {{.Name}}=42, got %d", c.{{.Name}})
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}Overwrite(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: 100 }
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr(42) }
	c.ApplyPartial(p)
	if c.{{.Name}} != 42 {
		t.Errorf("expected {{.Name}}=42, got %d", c.{{.Name}})
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}ZeroValue(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: 100 }
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr(0) }
	c.ApplyPartial(p)
	if c.{{.Name}} != 0 {
		t.Errorf("expected {{.Name}}=0 (zero value should be applied), got %d", c.{{.Name}})
	}
}
{{end}}{{if eq .TypeName "bool"}}
func Test{{$typeName}}ApplyPartial_{{.Name}}(t *testing.T) {
	c := &{{$typeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr(true) }
	c.ApplyPartial(p)
	if !c.{{.Name}} {
		t.Errorf("expected {{.Name}}=true, got %v", c.{{.Name}})
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}False(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: true }
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr(false) }
	c.ApplyPartial(p)
	if c.{{.Name}} {
		t.Errorf("expected {{.Name}}=false, got %v", c.{{.Name}})
	}
}
{{end}}{{if or (eq .TypeName "int32") (eq .TypeName "int64") (eq .TypeName "float64")}}
func Test{{$typeName}}ApplyPartial_{{.Name}}(t *testing.T) {
	c := &{{$typeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: mergePtr({{.TypeName}}(42)) }
	c.ApplyPartial(p)
	if c.{{.Name}} != 42 {
		t.Errorf("expected {{.Name}}=42, got %v", c.{{.Name}})
	}
}
{{end}}{{end}}{{end}}{{end}}{{end}}{{end}}
{{$typeName := .Name}}{{range .Fields}}{{if .IsSlice}}
func Test{{$typeName}}ApplyPartial_{{.Name}}Slice(t *testing.T) {
	c := &{{$typeName}}{}
	newSlice := {{.TypeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: newSlice }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected slice to be set")
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}SliceReplace(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: make({{.TypeName}}, 2) }
	newSlice := make({{.TypeName}}, 3)
	p := &{{$typeName}}Partial{ {{.Name}}: newSlice }
	c.ApplyPartial(p)
	if len(c.{{.Name}}) != 3 {
		t.Errorf("expected slice length 3, got %d", len(c.{{.Name}}))
	}
}
{{end}}{{end}}
{{$typeName := .Name}}{{range .Fields}}{{if .IsMap}}
func Test{{$typeName}}ApplyPartial_{{.Name}}Map(t *testing.T) {
	c := &{{$typeName}}{}
	m := make({{.TypeName}})
	p := &{{$typeName}}Partial{ {{.Name}}: m }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected map to be initialized")
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}MapMerge(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: make({{.TypeName}}) }
	m := make({{.TypeName}})
	p := &{{$typeName}}Partial{ {{.Name}}: m }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected map to remain initialized")
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}MapWithValues(t *testing.T) {
	c := &{{$typeName}}{}
	{{- if eq .TypeName "map[string]string"}}
	m := map[string]string{"key": "value"}
	{{- else if eq .TypeName "map[string]any"}}
	m := map[string]any{"key": "value"}
	{{- else}}
	m := make({{.TypeName}})
	{{- end}}
	p := &{{$typeName}}Partial{ {{.Name}}: m }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected map to be initialized")
	}
	if len(c.{{.Name}}) != len(m) {
		t.Errorf("expected map length %d, got %d", len(m), len(c.{{.Name}}))
	}
}
{{end}}{{end}}
{{$typeName := .Name}}{{range .Fields}}{{if and .IsPointer (not .IsStruct)}}
func Test{{$typeName}}ApplyPartial_{{.Name}}Pointer(t *testing.T) {
	c := &{{$typeName}}{}
	{{- if eq .TypeName "string"}}
	val := "test"
	{{- else if or (eq .TypeName "int") (eq .TypeName "int32") (eq .TypeName "int64")}}
	val := {{.TypeName}}(42)
	{{- else if or (eq .TypeName "float32") (eq .TypeName "float64")}}
	val := {{.TypeName}}(3.14)
	{{- else if eq .TypeName "bool"}}
	val := true
	{{- else}}
	val := {{.TypeName}}{}
	{{- end}}
	p := &{{$typeName}}Partial{ {{.Name}}: &val }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected pointer to be set")
	}
	{{- if or (eq .TypeName "string") (eq .TypeName "int") (eq .TypeName "int32") (eq .TypeName "int64")}}
	if *c.{{.Name}} != val {
		t.Errorf("expected value %v, got %v", val, *c.{{.Name}})
	}
	{{- end}}
}
{{end}}{{end}}
{{$typeName := .Name}}{{range .Fields}}{{if and .IsPointer .IsStruct (eq .TypePkg "")}}
func Test{{$typeName}}ApplyPartial_{{.Name}}NestedStruct(t *testing.T) {
	c := &{{$typeName}}{}
	p := &{{$typeName}}Partial{ {{.Name}}: &{{.TypeName}}Partial{} }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected nested struct to be initialized")
	}
}

func Test{{$typeName}}ApplyPartial_{{.Name}}NestedStructExisting(t *testing.T) {
	c := &{{$typeName}}{ {{.Name}}: &{{.TypeName}}{} }
	p := &{{$typeName}}Partial{ {{.Name}}: &{{.TypeName}}Partial{} }
	c.ApplyPartial(p)
	if c.{{.Name}} == nil {
		t.Error("expected nested struct to remain set")
	}
}
{{end}}{{end}}
{{end}}
`
